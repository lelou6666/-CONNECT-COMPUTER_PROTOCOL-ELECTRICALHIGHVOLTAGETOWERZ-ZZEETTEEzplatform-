Gridpoint Atlas 




Map the World Grid with Gridpoint Atlas

Home
 Introduction
 ProductsGridpoint Atlas®
 Books and Video
 White Papers
 
 Order
 About UsContact
 FAQ
 World Grid® Consulting Services
 Links
 Terms of Use and Service
 Privacy Policy
 Thank You
 
 


Rod Maupin and Bruce Cathie on Hidden Pyramids

April 15, 2015 By Rod Maupin —Leave a Comment 


Bruce Cathie and Rod Maupin on Ancient Aliens TV show
Image: Prometheus Studios

Bruce Cathie and Rod Maupin on Ancient Aliens 



 The episode of Hidden Pyramids that Bruce Cathie and I are in will be shown this Friday, 17 April, at 9:00pm EST, 9:00pm PST. It will be on the History Channel or History Channel 2, depending on where you live.

Ancient Aliens is shown on History Channel 2 in the U.S.

Hope you enjoy it.

 

“Hidden Pyramids” To Be Season 7 Episode 11 of Ancient Aliens

February 27, 2015 By Rod Maupin —Leave a Comment 


Bruce Cathie and Rod Maupin on Ancient Aliens TV show
Image: Prometheus Studios

Bruce Cathie and Rod Maupin on Ancient Aliens 



 I was contacted by the studio who produces the show and was told that the episode we will be featured on will be Episode 11.

The last new episode of Ancient Aliens was January 2 and that was Episode 9. There are re-runs of a couple prior shows that will be airing through March 10. Obviously, ours will be sometime after that.

Stay tuned.

Ancient Aliens is shown on History Channel 2 in the U.S.

 

Bruce Cathie & Rod Maupin’s Work to be Featured on Ancient Aliens

January 31, 2015 By Rod Maupin —6 Comments 


Bruce Cathie and Rod Maupin on Ancient Aliens TV show

Bruce Cathie and Rod Maupin on Ancient Aliens 



 If you are a fan of the Ancient Aliens television show, be sure to watch in February as Bruce Cathie’s and Rod Maupin’s work with harmonics and the World Grid will be featured. I don’t know the exact date, but it will probably show in February. It was supposed to show in January, but didn’t. So, it will undoubtedly be in February.

The episode will be called Hidden Pyramids.

Ancient Aliens is shown on History Channel 2 in the U.S.

 

They Say HAARP Alaska is Closing

October 25, 2014 By Rod Maupin —2 Comments 




The HAARP station in Gakona, Alaska
Photo: Wikipedia Commons


HAARP, Gakona, Alaska



 Over the past year and a half, there have been many articles stating that the U.S. Air Force will be closing the HAARP station in Gakona, Alaska. Here is one such article, from the Alaska Dispatch News:

Air Force plans to pull plug on Alaska’s controversial HAARP facility

Here is a quote from the article:

“Last summer the facility was temporarily shut down, but Ahtna Facility Services took over the operations and maintenance Sept. 30. But the Air Force says it can’t afford the $4 to $5 million a year its costs to run the site, the most powerful ionospheric heater in the world.”

Let’s review. The Air Force says it can’t afford the $4 to $5 million a year it costs to maintain the site. I find that very hard to believe. Since 9/11, the U.S. has been involved in ongoing war in the Middle East, which has cost at least $1 trillion dollars. They can afford perpetual war, but not a facility that costs $5 million a year. Yeah, right.

The only reason they would be closing down this facility is if they had something better in another location.

 

The Harmonics of the Higgs

August 10, 2014 By Rod Maupin —2 Comments 


By now, most people who have even a passing interest in science have heard of the Higgs Boson. Recently, I decided to check the harmonics of the reported mass for this particle. But first, let’s talk briefly about what the Higgs boson is.

The following excerpt is from Wikipedia, but there are lots of articles on the web about this subject:

“The Higgs boson or Higgs particle is an elementary particle initially theorized in 1964, whose discovery was announced at CERN on 4 July 2012. The discovery has been called “monumental” because it appears to confirm the existence of the Higgs field, which is pivotal to the Standard Model and other theories within particle physics. It would explain why some fundamental particles have mass when the symmetries controlling their interactions should require them to be massless, and why the weak force has a much shorter range than the electromagnetic force. The discovery of a Higgs boson should allow physicists to finally validate the last untested area of the Standard Model’s approach to fundamental particles and forces, guide other theories and discoveries in particle physics, and potentially lead to developments in “new” physics.”

“This unanswered question in fundamental physics is of such importance that it led to a search of more than 40 years for the Higgs boson and finally the construction of one of the world’s most expensive and complex experimental facilities to date, the Large Hadron Collider, able to create Higgs bosons and other particles for observation and study. On 4 July 2012, it was announced that a previously unknown particle with a mass between 125 and 127 GeV/c2 (134.2 and 136.3 amu) had been detected; physicists suspected at the time that it was the Higgs boson.”

On 14 March, 2013, “a Higgs boson of mass ~125 GeV was tentatively confirmed by CERN, although unclear as yet which model the particle best supports or whether multiple Higgs bosons exist.”

Let’s look at the harmonics of the mass of the Higgs Boson, 125 GeV.

Harmonics of the Higgs Boson
      Harmonics of the Higgs Boson


We see that the mass of the Higg’s Boson is tuned to Light Reciprocal.

Bruce Cathie wrote about Light Reciprocal many times in his books. But, I’ll give you a short review. What we call the Light Reciprocal harmonic is simply the reciprocal of the Speed of Light.

The maximum value for the Speed of Light at the Earth’s surface, at the equator, is 144000 nautical miles/grid second. In harmonics we ignore zeros to the left or right of the decimal.

Therefore, Light Reciprocal would be 1/144 = 694444444444.

That’s the same harmonic that is derived from the mass of the Higgs boson. Let’s take the next step.

If you take the value of Gravity Acceleration in the physics textbooks and convert it from meters per second squared to degrees per grid second squared, you get Light Reciprocal. Here is a screenshot from the Gridpoint Atlas software that illustrates this.

Conversion of Gravity Acceleration
Conversion of Gravity Acceleration


The above screenshot shows that Gravity Acceleration is converting to a different Light Reciprocal value, but the conversion is the same for whatever value of Gravity Acceleration you choose.

Since Light Reciprocal is a direct conversion of Gravity Acceleration, the mass of the Higgs boson is really tuned to the Gravity harmonic. Why is that significant?

Particle Physicists have been looking for a way to tie gravity into the Standard Model. Some physicists include the graviton in the Standard Model and some do not, but they readily admit they have never been able to detect a gravity wave. The graviton is a hypothetical boson, or force carrier, that transmits the force of gravity. They think it should be there, but they haven’t detected it yet.

Then there is the theory of Quantum Gravity which seeks to describe the force of gravity within the framework of Quantum Mechanics. The most popular approaches to the problem of quantum gravity are string theory and loop quantum gravity. We currently think of gravity in terms of the General Theory of Relativity, but that was formulated within the framework of classical physics. Therein lies a problem. Classical physics and quantum mechanics are radically different. One cannot consistently couple a classical system to a quantum one.

If you take a different approach and look at this problem harmonically, you see a direct connection with Gravity or Light Reciprocal. You don’t need to wait for a graviton to appear in a detector at CERN. The harmonic relationship to gravity is already there with the Higgs Boson.

However, I understand why they want to detect a graviton at CERN. The Large Hadron Collider is the most incredible machine ever built. We should continue to use it and get the most out of it. And frankly, it’s high time that big money is spent on big science. I mean, we pay professional athletes and Hollywood celebrities an obscene amount of money to provide entertainment. And while entertainment is nice, why shouldn’t the same kind of money be allocated for scientific research that leads to the advancement of our knowledge and new technology?

Let’s now look at the Higgs Field. The reported mass of the Higgs Field is 264 GeV. The Higgs Field is unique as it has a value even in its resting state. In other words, the value of the Higgs Field lying there in the background is always non-zero. This is how it is able to break symmetry and give mass to particles.

Harmonically, let’s look at the number of 264 GeV.

Harmonics of the Higgs Field
     Harmonics of the Higgs Field


 We see that the mass of the Higgs Field is tuned to the Energy harmonic, and it’s the Energy harmonic that corresponds to the Speed of Light in a Vacuum.

I sincerely hope we continue to do this kind of work in the future. I’m all for the righteous use of big science. But at the same time, I hope the day is not over where significant scientific discoveries can still be made by a single person working with a tabletop full of equipment.

At least, I hope those days aren’t over.

 

Will Gridpoint Atlas Plot the Grid in My Backyard?

July 18, 2014 By Rod Maupin —Leave a Comment 


By far, the most common question I get is whether the Gridpoint Atlas software can be used to plot the grid in this place or that place. Let me answer that once and for all.

Yes, Gridpoint Atlas will plot the grid anywhere in the world.

Here are some other common questions.


Question: Will Gridpoint Atlas tell me if my house sits on a grid line?

Answer: Yes, it plots the grid anywhere in the world.

Question: Will Gridpoint Atlas tell me if a grid line runs through my grandmother’s garden?

Answer: Yes, it will plot the grid anywhere in the world, even your grandmother’s garden.

Question: I think there is a dimensional portal in my back bedroom. Will Gridpoint Atlas tell me if that bedroom sets on a grid point?

Answer: Yes, it will plot the grid anywhere in the world.


 Now you know.

 

How to Plot World Grid in Gridpoint Atlas and View in Google Earth

April 30, 2014 By Rod Maupin —2 Comments 


Here is a new video that shows how to plot the World Grid in Gridpoint Atlas then view it in Google Earth. It shows you exactly how I use the program every day in my research.

Plot the World Grid in Gridpoint Atlas then view in Google Earth
Plot the World Grid in Gridpoint Atlas then view in Google Earth 

 

The Harmonics of B Flat (Bb)

February 20, 2014 By Rod Maupin —2 Comments 


Recently, I was watching Down From the Mountain, a Bluegrass concert of songs from the movie, O Brother Where Art Thou. At the beginning of the concert film, they had footage of the various musicians during rehearsal. Emmylou Harris was among the musicians and something she said caught my ear.

She was talking to Gillian Welch and Alison Krauss about Roy Huskey Jr., a bass player who died in 1997. Huskey has Synesthesia and saw musical notes as colors. At 20:33 in the film, Emmylou said,

“But you know what Roy Huskey said, that B Flat was the last note in the universe and it’s very very very black.”

That statement got my interest.

I did some searching on the internet and found that in 2003, scientists reported that the black hole in the Perseus cluster was emitting B Flat. Here is an excerpt from a post on the NASA website from November 17, 2003, Interpreting the Song Of a Distant Black Hole

“Using the piano keyboard’s middle C note as a reference point for the middle of the piano key music range, Fabian’s team determined the note is a B -flat. On a piano, the B-flat nearest middle C is located midway between 1/8th and 2/8th of an octave away. In musical terminology, this B flat is 1-1/2 steps from middle C.

The Perseus cluster black hole’s B-flat, by contrast, is 57 octaves below middle C or one million, billion times lower than the lowest sound audible to the human ear! In terms of frequency (the time it takes a single sound wave to pass by), the lowest sounds a person can hear is 1/20th of a second. The Perseus black hole’s sound waves have a frequency of 10 million years!”

At this point, I wanted to see if B Flat had a harmonic connection. So, I did some checking. It turns out that if you convert the value of B Flat, you will get the harmonic of the Speed of Light.

I’ll explain the calculations in this screenshot:


The Harmonics of B Flat



The Harmonics of B Flat (Bb)



 If you look up the frequency for B Flat (Bb 4) just below Middle C on a piano, you will find its value is 466.16 Hz. However, to check for harmonics you have to convert this value.

1 Hz is 1 cycle per second. But, what kind of second are we talking about? A second based on a 24 hour day or a day broken into 24 periods. To work in grid units, you have to use a 27 hour day, or a day broken into 27 periods. Using the Gridpoint Atlas software, I converted the value.

The first value of 466.16 is in normal time or hertz. I have labeled this as normal time – actual.

The second value of 414.3644444444444 is after I have converted it to grid time. I have labeled this as grid time – actual.

I took the grid time value and checked the harmonic. If I shifted the value slightly to 414.3596158564265 (grid time – calculated), I found it would yield the Maximum value for the Speed of Light or 144000.0000.

If you then convert that value from grid time back to normal time, you will get the fourth value, 466.1545678384798, which I have labeled as normal time – calculated.

What all this means is that the value of B Flat that yields the harmonic is 466.154 which is slightly off from the published value of 466.16.

I made two sine wave sound files, one with a frequency of 466.16 and one with a frequency of 466.154 and then listened to them. The human ear can’t tell the difference between the two.

Interestingly enough, if you check the values of all B Flats on the piano, Bb 1 through Bb 8, you will find that each yields the harmonic of the Speed of Light. Although it’s not always the same Speed of Light harmonic.

Perhaps the musical scale should be centered around B Flat, rather than Middle C.

 

What is the Difference Between 30′, 7.5′, 6′ and 1′ Grid Lines?

December 8, 2013 By Rod Maupin —6 Comments 


One of the most common questions I am asked is what is the difference between 30′, 7.5′, 6′ and 1′ grid lines? Here is what Bruce Cathie and I learned over time about this subject.

Originally, when Bruce was starting his research into the World Grid and harmonics, he plotted sightings of UFOs on a map of New Zealand. After he had plotted a lot of sightings, he noticed that he could draw a set of lines that would connect the sightings. These lines formed a grid pattern and by measuring, he found that the lines were 30′ apart. When I say 30′, I mean 30 minutes of arc or 30 nautical miles.

Here is what his original map looked like:


Original World Grid Map Showing UFO Sightings Over New Zealand



Original World Grid Map from 1965 Showing UFO Sightings Over New Zealand



 In the original map, UFO sightings are shown by circles on the map. As you can see, some sightings were on grid lines, some were on grid points.

In time, Bruce learned that he could further subdivide the 30′ grid into a system of 7.5′ grid lines. After much study, he found that the 7.5′ grid lines were also valid. Since 7.5 x 4 = 30, the 30′ grid divided evenly into 7.5′ segments.

In 1989, I began working with Bruce and in 1993 we released the first version of Gridpoint Atlas, our software which calculates harmonics and calculates the World Grid. In 1993, we could calculate grid points anywhere in the world, but we couldn’t plot them on a digital map until around 2000. Today, our software creates ESRI-compatible and Google Earth-compatible grid files. You can view the grid files in ESRI software or in Google Earth. Having these capabilities helped the research progress immensely.

Through decades of research, we have found that there are 30′, 7.5′ and 6′ grid lines. We feel that these are the major grid lines of the grid. We have also found that 1′ grid lines are valid and very important, but we consider these to be minor grid lines.

Now, the World Grid is infinite and there are trillions and trillions of points all over the Earth. We feel that the major grid lines can be subdivided down into increments of multiple seconds, but we do not know exactly what increments are valid.

If you work with the Gridpoint Atlas software and plot 30′, 7.5′, 6′ and 1′ grid lines, you will be dealing with the most important ones and you will find that the majority of the sites around the world, including ancient structures, monuments, scientific installations, particle accelerators and many other facilities will be found with these grid lines running through them.

Let’s look at one of the modern sites that sits on several grid lines.


30', 7.5', 6', and 1' grid lines going through Temple Square in Salt Lake City, Utah, USA


30′, 7.5′, 6′, and 1′ grid lines going through Temple Square in Salt Lake City, Utah, USA



 In the above screenshot, we see Temple Square in Salt Lake City, Utah. This is the headquarters of the Mormon church. Here is one example where 30′, 7.5′, 6′ and 1′ grid lines line up on the same line and run through a facility. On the left, the oval-shaped structure is the original tabernacle that was first built on this site. On the right, is the most recent tabernacle that was built afterwards and is the one that has all the grid lines running through it. This is notable because it is the only religious site in the world we have found to have the characteristic of so many grid lines lining up and running through it. Very unusual. Obviously, the Mormons were led to this place for a reason. This is no accident.

In the Gridpoint Atlas software, we also allow the user to enter his own grid resolution, just as long as it’s a harmonic of 360 degrees, meaning the value has to be be able to be divided into 360 an even number of times. This allows people to do their own research and come to their own conclusions.

You may wonder why there isn’t just one set of grid lines, say 7.5′ apart and that’s it? Why all the others? Well, I don’t know. Something greater than you and I created it. And all evidence shows that the grid is made up of an amazing lattice of major and minor lines, some being very fine. This lattice creates the world that we live in, interact with and see everyday.

Now ancient structures, ancient and modern monuments, scientific installations, government installations and particle accelerators are not the only things sitting on major grid lines. There are a lot of people’s homes that sit on major grid lines and grid points all over the world. For example, John and Jane Doe who live at 123 Main St. in Anytown, USA don’t know that their house sits on a major grid point. And their relatives who live in a neighboring state don’t know that a major grid line runs through their farm. However, they may feel better because of it. I don’t know but it surely has some effect. We just can’t definitely say what it is.

When you plot the grid and see what sites around the world fall on it, it becomes clear that the knowledge of harmonics and the grid is in use today as it was thousands of years ago. It’s just it’s used by scientists, government workers and others who still keep the information from the public because they feel they don’t have a right to know. Bruce Cathie was even told by one of these people that, “it wouldn’t be right for the public to know. It would hurt them.” That’s ridiculous and I’ll tell you why.

If this knowledge was allowed to be used by the public, the only people it would hurt are those who have kept it secret from the public. Because it would threaten their monopoly of power. That’s it plain and simple.

 

Misconceptions about Bruce Cathie’s Atomic Test Calculations

October 11, 2013 By Rod Maupin —6 Comments 


A reader emailed me recently and asked if it was possible for a nuclear weapon to go off in Charleston, South Carolina in the late fall. This person was probably asking about it because of comments U.S. Senator Lindsey Graham (R – S.C.) made to reporters in Goose Creek, South Carolina on Tuesday, September 3, 2013.

Here is the report from the CBS news affiliate in Charlotte:



“Graham told reporters in Goose Creek on Tuesday that taking action against Syria in response to the situation is not a question of yes or no, but rather a question of bad or worse choices.”



 “He says if there is no U.S. response, Iran will not believe America’s resolve to block Iran from developing nuclear weapons. Graham also says those nuclear weapons in the hands of terrorists could result in a bomb coming to Charleston Harbor.”



The link to the full article is at the following address:

Graham: Nukes In Hands Of Terrorists Could Result In Bomb Coming To Charleston Harbor

Now, let’s get back to the email I received. The reader is specifically asking me because of what Bruce Cathie published in his book Harmonic 33 in 1968 about atomic tests. He had been watching the atomic bomb tests done by the French at Moruroa Atoll and noticed that whenever an atomic test was successful, the same harmonics of the Speed of Light, Gravity, and the Earth’s Magnetic Field were present that were built into the World Grid and many ancient structures.

I’m not revealing any classified secrets here, this was first published by Bruce in 1968. Here is an excerpt from page 74 of his book, Harmonic 33:



“Is it possible to fight an atomic war on this basis? The whole thing would be completely illogical because both countries involved would naturally have computers calculating in advance just where and when each and every bomb would have to be placed if it was to explode. It is interesting to note that the American scientists can calculate in advance when the Chinese will detonate a bomb. If someone were stupid enough to push the button and start a war, then the country with the best defence would probably be the victor. Probably this is the reason for deploying submarines around the world, well stocked with atomic rockets. They could wait undetected over a long period, and fire their rockets as the Sun moved into position.”



If you want to learn more about this, I refer you to Bruce Cathie’s books. He wrote about the subject in each of the books he published over the years.

Over the 23 years Bruce Cathie and I worked together, we had many conversations on this subject. And over the years, I have noticed that people’s reactions to this information was often based on a misunderstanding of what Bruce originally wrote. Therefore, I’m going to clear this up.

Here are the top three misconceptions I have heard:
1.Nuclear weapons can only be exploded on grid points.
2.Nuclear weapons can only be exploded at certain places around the world.
3.Nuclear weapons are just like a firecracker or a stick of dynamite. You just drop it and it goes off. Or you just place the nuke, push the button, and it goes off.

All of these are incorrect. The harmonic component of the detonation is what the public has not known about for over 60 years. They don’t know because that missing piece has been kept from them on purpose.

Let me give you a disclaimer about Bruce and I. We felt that if you wanted to build one of these devices and get it to work, you had to know three things, or at least have a team of people who collectively knew and understood these three things:
1.Nuclear Physics
2.How to build an atomic weapon
3.Harmonics

Bruce didn’t know and I don’t know anything about items 1 and 2. More importantly, we haven’t ever wanted to know anything about items 1 and 2. Frankly, anyone who knows all three things should only work for one of the governments, because this information shouldn’t be walking around out there unless you are part of some government organization.

Having said that, Bruce understood and I understand item 3, the harmonic component in this equation.

Bruce learned about this by observing the French atomic tests. He felt people had a right to know, so he published the information in all of his books. He was later contacted by multiple 3-letter agencies, the most important being the CIA. The CIA tried to buy him off and shut him up. He refused to go to work for them, so they had all his books destroyed. In fact for many years, he was unable to get any book published.

Let’s get back to the misconceptions. All three are incorrect. Nuclear weapons can be detonated anywhere. However, for a given location, the sun has to be in a position relative to that detonation location such that, the geometric harmonics are present for the nuke to go off and cause massive collateral damage. If the harmonics are not present, you won’t have massive damage of an area and will probably (we think) just get a large release of radiation.

Now, that’s all we know on the subject. Bruce Cathie mentioned it in each of his books, but in his personal research, he never worked on it again. He felt there were far more interesting things in the world to look at than this topic. I feel the same way.

Let’s look at modern day terrorism. Could a terrorist get their hands on a nuke and detonate it in a major U.S. city or even Charleston harbor? First they would have to get the nuke. There have been reports over the years that 100 suitcase nukes went missing from the former Soviet Union years ago. No one knows where they are. So, let’s say someone could get their hands on one of these if they were well-financed. Then what?

They would have to have very specialized knowledge in order to pull this off. Frankly, I don’t think a terrorist, with minimal education, just a crazed religious fervor and large bankroll, could get one of these things and get it to detonate. In fact, I don’t think it will ever happen. If they did, they would have had to have very specialized help from someone on the inside. Or at least someone who used to be on the inside of some specialized government scientific group.

Getting back to Senator Lindsey Graham’s comment, could a nuke go off in Charleston harbor? Only if the person or persons detonating it had very specialized knowledge. Remember detonating a nuclear device is not like lighting a stick of dynamite. With a nuke, you just don’t push a button and it goes off and levels a city.

For the skeptics out there, you don’t have to write and disagree with me. I’ve heard it all before. If you think what I’m telling you is ridiculous, then why would the CIA have tried to buy Cathie off and shut him up years ago? Why did they have all his books destroyed?

Think about that.


Update 21 November, 2013: It is pretty much 100% guaranteed that the nuclear capability has evolved since Bruce originally published this information in 1968. I am sure they have miniaturized the technology and they may even evolved it to the point where the same conditions do not apply. Of course, the laws of physics haven’t changed and the rules of harmonics haven’t changed, but undoubtedly the technology has. As I mentioned earlier, this is all I know on the subject as it is not been my focus.


 

How to Take the Coordinate of a Structure from Google Earth

October 3, 2013 By Rod Maupin —2 Comments 


When you are doing research on various sites around the world, you want to get the most accurate coordinates you can. However, in talking with many people, it’s apparent that some do not know the proper way to do this.

I will show you a classic example, the Pyramid of Khufu from the Giza Complex in Cairo, Egypt. Here is a screenshot from Google Earth:

Pyramid of Khufu, Giza Complex, Cairo, Egypt
Pyramid of Khufu, Giza Complex, Cairo, Egypt 

A lot of people would take the coordinate of the apex of the pyramid. However, that would not be correct. This is because the satellite was not directly above (over the center) when the image was taken. Therefore, the apex of the pyramid is off center. However, the solution is very simple. Don’t use the apex.

Have a look at this screenshot.

Take the coordinate from the center of the base
Take the coordinate from the center of the base 

Instead, you want to take the coordinate of the center of the structure at the base, not the apex or in the case of a building, not a point on the roof.

If you follow this rule, the coordinates will not change as Google Earth updates its satellite imagery.

 

Gridpoint Atlas Software is Still Available for Purchase

September 2, 2013 By Rod Maupin —2 Comments 


I have had a lot of questions recently about the Gridpoint Atlas software and whether it was still available for purchase. The answer is YES.

Despite the passing of Bruce Cathie, the Gridpoint Atlas software will still be available now and in the future. Although Bruce and I worked on it together for 23 years, I was the software developer and will continue to upgrade it as new findings are made.

If you are interested, you can learn about the software here:

The Gridpoint Atlas Software 

Thanks for all the inquiries.

Rod Maupin
 2 September, 2013

 

Bruce Leonard Cathie 1930 – 2013

June 3, 2013 By Rod Maupin —15 Comments 


Bruce Leonard Cathie 1930 - 2013
Photo: The Harmonic Code (DVD) 



 My great friend, Bruce Cathie, passed away on June 2, 2013 at North Shore Hospice in Auckland, New Zealand. He went peacefully after a lengthy illness.

After reading a couple of his books, I started corresponding with him in 1988. We became friends and started working together in 1989. It was a rare friendship in that we always got along and never had a disagreement, about anything. We were always on the same page.

Over the years, Bruce was my mentor and very graciously taught me everything that I now know on the subject of harmonics. He never grew tired of my endless questions and had a knack for explaining difficult concepts in language that I could understand. Although I must admit that some of his concepts took me years to fully understand.

His genius and his legacy was that he drew correlations between past and modern-day events, ancient structures, UFO sightings, then put them all-together and uncovered the World Grid system that has been a part of this planet from the very beginning. Much to the disdain of the academic world, he extended Einstein’s famous equation. However, they were just jealous they hadn’t done the same. He also created a table of Unified Harmonics that has stood the test of time. 

Over the years, many tried to silence him. At times, he and his family had to endure many hardships as his published works drew the attention of intelligence agencies around the world. Their scientists and agents were eager to keep this information out of public view as it had been hidden for thousands of years. However, he ignored their threats, continued on with his work and always published his findings. He felt the public had the right to know. He was a true maverick and one day the world will realize the full extent of his genius.

I must remind people that in the 20th century, he was THE first grid researcher. He was the one who painstakingly derived all of the information on his own. Because there were no references out there, there were no books on the subject, there were no classes taught on harmonics in the universities. Every single grid researcher that is around today came after him, because in one way or another, they were inspired by him and his work. Whether directly or indirectly.

I can say that the greatest thing I learned from my best friend was to always be secure in my own knowingness. Because that’s what he always did. No matter what anybody said, what anybody did or what anybody thought, he carried on tirelessly with his work for decades. The majority of that time working alone and with no help from anyone. Surely that is an example we can all learn from.

I will miss him greatly. I also know the legions of fans who read his books and followed his work through the years will miss him as well.

My thoughts are with his wife, Wendy, and his sons, Mark and Stephen. 

My pledge is to make sure the world never forgets what he accomplished.


 Rod Maupin
 Rainier, WA
 USA
 June 3, 2013

 

Diamond Light Source Spins Particles on the World Grid

September 9, 2012 By Rod Maupin —Leave a Comment 


Diamond Synchrotron Light Source Sits on a 1' Grid Line



Diamond Synchrotron Light Source Sits on a 1′ Grid Line



Diamond Light Source is the United Kingdom’s national synchrotron facility located in Oxfordshire, United Kingdom. Its purpose is to produce intense beams of light whose special characteristics are useful in many areas of scientific research.

The synchrotron can be used to investigate the structure and properties of a wide range of materials from proteins and engineering components to conservation of archeological artifacts.

Diamond Light Source generates synchrotron light at wavelengths ranging from X-rays to the far infrared. This is also known as synchrotron radiation and is the electromagnetic radiation emitted by charged particles traveling near the speed of light. It is used in a variety of experiments to study the structure and behavior of different types of matter.

We have analyzed the particle accelerator sites worldwide and have found that the overwhelming majority sit on grid lines. In this case, the Diamond Light Source sits on a 1′ grid line. Although a 1′ grid line is what we would consider to be a minor grid line, it doesn’t mean this facility is less important than other accelerators that sit on major grid lines.



Buy Gridpoint Atlas 4.0

 

Windsor Castle Was Built on the World Grid

September 2, 2012 By Rod Maupin —Leave a Comment 


Aerial view of Windsor Castle



Aerial view of Windsor Castle



Windsor Castle is a medieval residence in Windsor in the English county of Berkshire. It is notable for its long association with the British royal family and is also known for its architecture.

The original castle was built by William the Conqueror after the Norman invasion. Since the time of Henry I, it has been used by a succession of monarchs and is the longest-occupied palace in Europe. The castle’s lavish, early 19th-century Apartments are architecturally significant and the castle includes the 15th-century St George’s Chapel, considered to be one of the supreme achievements of English Perpendicular Gothic design.

Queen Victoria made minor changes to the castle, which became the center for royal entertainment during much of her reign. The Castle was also used as a refuge for the royal family during the bombing campaigns of the Second World War and survived a fire in 1992. It is a popular tourist attraction, a venue for hosting state visits, and the Queen’s preferred weekend home.


Windsor Castle sits on a 6' grid line



Windsor Castle sits on a 6′ grid line



 Since it was a royal residence and has enjoyed such a long history, we were curious if the castle sat on a major grid line. After plotting in Gridpoint Atlas and viewing in Google Earth, we found that it was.

Windsor castle was built on a 6′ grid line. The line is actually continuous, even though Google Earth is showing it as broken. GE sometimes does that when you zoom in and out.



Buy Gridpoint Atlas 4.0

 

Huang-ti Mausoleum, Shaanxi Province, China Sits on the World Grid

August 25, 2012 By Rod Maupin —Leave a Comment 


Huang-ti Mausoleum in China sits on a 7.5' grid line



Huang-ti Mausoleum in China sits on a 7.5′ grid line



Ch’in Shih-huang-ti was a powerful figure in ancient Chinese history. During his rule, he unified much of China with a government that was based on the teachings of Legalism. It was under Ch’in Shih-huang-ti that much of the Great Wall of China was built, as well as a huge burial compound known as the Ch’in tomb.

To protect his state from a Hunnish tribe of people to the north known as the Hsiung Nu, Ch’in Shih-huang-ti embarked on an amazing effort to connect the walls and fortresses, created during the Warring States Period, to protect his kingdom. The result was the Great Wall of China.

Another structure of astonishing proportions built under Ch’in Shih-huang-ti was a massive burial compound, known as the Ch’in Tomb. It was discovered byarchaeologists in 1974, near the present-day city of Xiam. The tomb, encompassing 20 square miles (50 sq km), was a huge subterranean complex, landscaped to resemble a low, wooded mountain. In the chamber, 6,000 life-sized terracotta soldiers were found in battle formation, and in adjoining chambers thousands of smaller figurines were found. A stable of skeletonized horses was discovered and the remains of bronze gilded chariots accompanied them. Valuable gems, jade carving of trees and animals, as well as silks were also unearthed. The emperor’s actual burial tomb has yet to be excavated. It was purported that it took 700,000 men more than 36 years to complete.

When you look at the accompanying screenshot, you see that the tomb was built on a 7.5′ grid line and at one time may have been situated on a grid point. We feel that sites this close to a major grid line or point were in fact on it when they were originally built. Over time, earthquakes or plate movements may have caused the original placement to shift.



Buy Gridpoint Atlas 4.0

 

George Washington Masonic Memorial Sits on the World Grid

July 30, 2012 By Rod Maupin —Leave a Comment 


George Washington Masonic Memorial sits on a 7.5' grid line



George Washington Masonic Memorial sits on a 7.5′ & 1′ grid lines



 The George Washington Masonic National Memorial is a Masonic building and memorial located in Alexandria, Virginia, just outside Washington, D.C. It is dedicated to the memory of George Washington, the first President of the United States, who was also a Mason.

The design of the tower was patterned after the ancient Lighthouse of Alexandria in Egypt, one of the Seven Wonders of the Ancient World.

What’s interesting about this memorial is that it sits on 7.5′ and 1′ grid lines. Both major and minor World Grid lines are covered here.

The placement of the memorial on this site is hardly accidental.



Buy Gridpoint Atlas 4.0

 

NSA Utah Data Center Is Being Built On the World Grid

July 9, 2012 By Rod Maupin —Leave a Comment 


The National Security Agency (NSA) is currently constructing its new Utah Data Center in Bluffdale, Utah. Most people know that the NSA has become the largest, most covert, and most intrusive intelligence agency ever. But few know about this new data center and what kind of work they will be doing there.



Buy Gridpoint Atlas 4.0



Bluffdale sits in a bowl-shaped valley in the shadow of Utah’s Wasatch Range to the east and the Oquirrh Mountains to the west. It’s in the heart of Mormon country, where religious pioneers first arrived more than 160 years ago.

When completed, the $2 Billion Utah Data Center will be more than five times the size of the US Capitol and will secretly capture, store, and analyze vast quantities of words and images traveling through the world’s telecommunications networks.

The center is under construction by contractors with top-secret clearances. It’s a project of immense secrecy and its purpose is to intercept, decipher, analyze and store vast amounts of the world’s communications as they bounce down from satellites and rip through the underground and undersea cables of international, foreign, and domestic networks. The heavily fortified center should be up and running by September 2013. Flowing through its servers and routers, and stored in near-bottomless databases will be all forms of communication, including the complete contents of private emails, cell phone calls, and Google searches, as well as all sorts of personal data trails, including parking receipts, travel itineraries, bookstore purchases, and vast amounts of other digital information.

Knowing all this, we have to ask, “Why did the NSA picked this particular location to build its data center?” The site is located adjacent to Camp Williams, a U.S. military base. We know that the NSA likes to build on or near U.S. military bases. In fact, the NSA’s headquarters is located on the grounds of Fort Meade in Maryland.

I decided to plot the location in Gridpoint Atlas and view it in Google Earth. When I did, I found that a 7.5′ grid line goes right through the center of the site. Here is a screenshot of the site. You will notice that an airport used to exist at the same location.


NSA Utah Data Center in Bluffdale, Utah showing a major 7.5' grid line



NSA Utah Data Center in Bluffdale, Utah showing a major 7.5′ grid line



 The next screenshot shows the Google Earth satellite imagery with the data center site plan overlaid. The site plan shows the future buildings. At least those above ground. You can see that the 7.5′ grid line goes right through the center of the complex.


NSA Utah Data Center Site Plan



NSA Utah Data Center Site Plan



 We can see that the selection of this site was not an accident.



Buy Gridpoint Atlas 4.0

 

Medicine Hat on the World Grid

June 10, 2012 By Rod Maupin —Leave a Comment 




A 7.5' grid line goes through Medicine Hat in Alberta, Canada


A 7.5′ grid line goes through Medicine Hat in Alberta, Canada



 A reader reported this site to us and we decided to plot it.

Medicine Hat is a city of 61,000 people located in the southeastern part of the province of Alberta, Canada. It is situated on the Trans-Canada Highway, the eastern terminus of the Crowsnest Highway, and the South Saskatchewan River.

As far as we are concerned, the most interesting part of this area is the hill formation that can be seen in the Google Earth plot above. From the air, it appears to be in the shape of an Indian wearing a headdress. Also, a 7.5′ grid line that goes right through it.

Major grid lines going through natural land formations are actually quite a common thing. We see this often. Other examples are Stone Mountain in Georgia, USA and Ayers Rock in Australia.

You can see that the grid line actually goes through the chin/mouth area of the Indian’s head. We wonder if he’s trying to say something?

We just found this site to be interesting.

 

Mysterious Black Rectangle in Alaska is on the World Grid

April 29, 2012 By Rod Maupin —4 Comments 


Mysterious Black Rectangle in Alaska sits on a 7.5' grid line



Black Rectangle in Alaska sits on a 7.5′ grid line



 If you fire up Google Earth and go to 62.193766, -141.262196, you will see a large black rectangle in Alaska, USA.



Click to learn more about Gridpoint Atlas 4.0



 When I saw this rectangle, I immediately went into the Gridpoint Atlas software and plotted various resolution of grids for that area, then viewed the plots in Google Earth. I found that a 7.5′ grid line runs right through the large black rectangle.

We can speculate that this area is being censored because it’s some kind of U.S. military installation that they don’t want us to see. After all, it is in close proximity to Russia. If you look at the placemarks other people have placed on the area, you’ll see that some feel it is some kind of HAARP facility. I doubt it, since other HAARP facilities have not been censored in Google Earth. However at this point, your guess is as good as mine.

This is all speculation, but it is interesting that a major 7.5 nautical mile grid line goes right through the area.

 

Mysterious Lights of Marfa, Texas and Bragg Road, Texas, USA

April 17, 2012 By Rod Maupin —1 Comment 


Bruce Cathie has written a white paper on the famous lights of Marfa, Texas and the ghost lights of Bragg Road near Saratoga, Texas.

In the paper, he talks about apparent reasons for the lights and whether these two sites are connected.

Check it out here:

Mysterious Lights of Marfa and Bragg Road, Texas, USA

 

Omega Transmitter in Australia on the World Grid

April 15, 2012 By Rod Maupin —Leave a Comment 


A while back, a user of the Gridpoint Atlas software informed me of a site I was not familiar with, the Omega transmitting station in Australia. Here’s the description of that facility from Wikipedia:



Buy Gridpoint Atlas 4.0



The Omega Transmitter is located near Woodside, Victoria, Australia at 38.481228°S 146.935294°E. It uses an umbrella antenna carried by a 432 metre high grounded lattice steel guyed mast. This mast is the highest construction in the southern hemisphere.

Construction of this station was originally planned to be built in New Zealand but after protests from anti-war protestors, it was built in Australia.

After the shutdown of the OMEGA navigation system, it was used until 2004 as a transmitter for orders to submarines on 13 kHz under the callsign VL3DEF. Until December 2008, it had been transmitting a 100 baud MSK modulated signal on 18.6 kHz. However, the station has been closed down and transmissions have now ceased. The tower remains, but the transmitting equipment is on display at the Port Albert Maritime Museum.

Here is the screenshot of the Omega transmitter from Google Earth.


Omega Transmitter in Australia was placed on a 7.5' grid line



Omega Transmitter in Australia was placed on a 7.5′ grid line



 As you can see, when I plotted the Omega station, I found that it had been placed on a 7.5′ grid line that goes through the center of the tower.



Buy Gridpoint Atlas 4.0

 

The Statue of Liberty Shines on the World Grid

February 16, 2012 By Rod Maupin —2 Comments 




 Recently on a hunch, we wondered if the Statue of Liberty in New York City harbor was on the World Grid. We plotted the area and found out it was. Here’s the story.

The original Statue of Liberty was built on the Île aux Cygnes, river Seine in Paris, France. It is near the Pont de Grenelle.

The Île aux Cygnes is a man-made island in the river Seine (48°51′0″ N, 2°16′47″ E), 11.50 m high (37 feet 9 inches). Inaugurated on July 4, 1889, it looks southwest, downriver along the Seine. Its tablet bears two dates: “IV JUILLET 1776″ (July 4, 1776: the United States Declaration of Independence) like the New York statue, and “XIV JUILLET 1789″ (July 14, 1789: the storming of the Bastille).

The Statue of Liberty on Liberty Island in New York City harbor was a gift to the United States from the French people. It was designed by Frédéric Bartholdi and was dedicated on October 28, 1886. The statue is of a robed female figure representing Libertas, the Roman goddess of freedom, who bears a torch and a tabula ansata (a tablet evoking the law) upon which is inscribed the date of the American Declaration of Independence, July 4, 1776. A broken chain lies at her feet. The statue has become an icon of freedom and of the United States.

In the Gridpoint Atlas software, the first grid we plotted happened to be the one the statue was built on, the 7.5′ grid. In fact, the grid line goes right through the exact center of the statue’s base. Here is a screenshot.


The Statue of Liberty was placed on a 7.5' grid line



The Statue of Liberty was placed on a 7.5′ grid line



 You can’t get any more blatant than that.

Interesting how most of these things are hiding in plain sight.

 

Saddam Hussein’s Babylon Palace on the World Grid

January 30, 2012 By Rod Maupin —Leave a Comment 


Here is another interesting plot we found with the Gridpoint Atlas software. This is Saddam Hussein’s Babylon Palace.

When Saddam Hussein rose to power in Iraq, he wanted to rebuild the ancient city of Babylon. At the time, he said that Babylon’s great palaces and the legendary Hanging Gardens of Babylon would arise from the dust. You might recall that the Hanging Gardens of Babylon were one of the Seven Wonders of the Ancient World.

In 1982, Saddam Hussein’s workers began the work of reconstructing Babylon’s most imposing structure, the 600-room palace of King Nebuchadnezzar II. At the time, archaeologists were mortified, and said that rebuilding on top of ancient ruins did not preserve history, but desecrated it.

The original bricks, which still exist and rise two to three feet above the ground, bear ancient inscriptions praising Nebuchadnezzar. Not to be outdone, Saddam Hussein’s workers laid more than 60 million sand-colored bricks on top of the original bricks. They were inscribed with the words, “In the era of Saddam Hussein, protector of Iraq, who rebuilt civilization and rebuilt Babylon.” However, lofty words were not enough to keep the new new bricks from cracking after only ten years.


Saddam Hussein's Babylon Palace lies on a 7.5' grid line


Saddam Hussein’s Babylon Palace lies on a 7.5′ grid line



 We have no idea if Saddam Hussein knew about the World Grid. Perhaps the credit for building on a major grid line should go to King Nebuchadnezzar II, for he is the constructor of the original building that stood on the grounds.

Get Gridpoint Atlas

 

The ALBA Synchrotron on the World Grid

December 29, 2011 By Rod Maupin —Leave a Comment 


ALBA is a synchrotron radiation facility in Cerdanyola del Vallès near Barcelona, Catalonia, Spain. It was constructed and is now operated by the CELLS consortium (Consortium for the Exploitation of the Synchrotron Light Laboratory), and co-financed by the Spanish and Catalan governments.

After almost ten years of planning and design by the Spanish scientific community, the project was approved in 2002. The facility was redesigned in 2004 and construction was started in 2006. The laboratory was officially opened for experiments on March, 2010.


ALBA Synchrotron Radiation Facility is centered on a 1' grid point



ALBA Synchrotron is centered on a 1′ grid point



 A few months ago, we were studying the placement of all the world’s particle accelerators to see their relationships to the World Grid. After plotting the World Grid for this area in Gridpoint Atlas, we viewed the plot in Google Earth and saw what is shown above.

This is one of the more interesting plots we’ve come across. Obviously, the precise placement of the facility was no accident.

 

Religious Temples on the World Grid

October 22, 2011 By Rod Maupin —4 Comments 


In checking religious temples and sites on the World Grid, we have found many, many hits. Here are three examples that will be very interesting to you. The fact that they are placed on grid lines is very telling and is proof that the builders of these places had access to ancient knowledge.

7.5' grid line going through the Angkor Wat Temple in Angkor, Cambodia


7.5′ grid line going through the Angkor Wat Temple in Angkor, Cambodia




Angkor Wat is a temple complex in Angkor, Cambodia. Built for King Suryavarman II in the early 12th century as his state temple and capital city. As the best-preserved temple at the site, it is the only one to have remained a significant religious centre since its foundation.

It is the world’s largest religious building. The temple is at the top of the high classical style of Khmer architecture. It has become a symbol of Cambodia, appearing on its national flag, and it is the country’s prime attraction for visitors. Angkor Wat combines two basic plans of Khmer temple architecture: the temple mountain and the later galleried temple, based on early South Indian Hindu architecture, with key features such as the Jagati. It is designed to represent Mount Meru, home of the devas in Hindu mythology: within a moat and an outer wall 3.6 kilometres (2.2 mi) long are three rectangular galleries, each raised above the next. At the centre of the temple stands a quincunx of towers.

Unlike most Angkorian temples, Angkor Wat is oriented to the west; scholars are divided as to the significance of this. The temple is admired for the grandeur and harmony of the architecture, its extensive bas-reliefs, and for the numerous devatas (guardian spirits) adorning its walls.

1' grid line going through the Sri Padmanabhaswamy Temple in Thiruvananthapuram, India


1′ grid line going through the Sri Padmanabhaswamy Temple in Thiruvananthapuram, India




Sri Padmanabhaswamy temple is a Hindu temple located in Thiruvananthapuram, India. The shrine, dedicated to Lord Vishnu, is currently run by a trust headed by the royal family of Travancore.

In June 2011, the Supreme Court directed the authorities from the archaeology department and fire services to open the secret chambers of the temple for inspection of the items kept inside. The review of the temple’s underground vaults lead to the enumeration of a vast collection of treasures that are traditionally kept under lock and key. The detailed inventory revealed gold, jewels, and other valuables, and has solidified the Padmanabhaswamy temple to be one of the wealthiest temples in India. The final estimate of wealth to said to be US$7.14 billion.

30', 7.5', 6', and 1' grid lines going through Temple Square in Salt Lake City, Utah, USA


30′, 7.5′, 6′, and 1′ grid lines going through Temple Square in Salt Lake City, Utah, USA




Readers in the US will immediately recognize this as the famous Temple Square in Salt Lake City, Utah, USA. It is the worldwide headquarters of the Church of Jesus Christ of Latter-Day Saints (LDS), also known as the Mormon church.

Temple Square is a ten acre complex located in the center of Salt Lake City, Utah. In recent years, the usage of the name has gradually changed to include several other church facilities immediately adjacent to Temple Square. Contained within Temple Square proper are the Salt Lake Temple, Salt Lake Tabernacle, Salt Lake Assembly Hall, the Seagull Monument and two visitors’ centers.

What makes this place unique is that it is positioned where four different resolution grid lines (30′, 7.5′, 6′ and 1′) line up in the same place. So far, this is the only religious site we have found to have this characteristic. This means that undoubtedly, the founders of the church had access to very advanced knowledge. People can argue whether they knew the information or were given it. Some will even say they were led to the exact place. However, that is a debate we will leave to others. All we are saying is that the placement of Temple Square could not have been an accident.

 

Chateaus and Palaces on the World Grid

September 18, 2011 By Rod Maupin —1 Comment 


You may have wondered if some of the world’s most famous chateaus and palaces are built on the World Grid. Many are.

We have looked at hundreds of sites and want to show three examples. Enjoy!

6' grid line going through the Chateau Azay-le-Rideau in France


6′ grid line going through the Chateau Azay-le-Rideau in France




The screenshot above is of the Chateau Azay-le-Rideau in Azay-le-Rideau, France. It was built from 1515 to 1527, and is one of the earliest French Renaissance châteaux. Built on an island in the Indre River at Azay-le-Rideau, its foundations rise straight out of the water.

The Treasurer-General of the Finances of France under King Francis I and mayor of Tours, began reconstructing Azay-le-Rideau’s earlier medieval castle, that was part of his wife’s inheritance. However, it was his wife, Philippe Lesbahy, who directed the course of the works, including its central internal staircase (escalier d’honneur) that is Azay’s greatest most remarkable feature, inspired by the staircase at Châteaudun.

As you can see, a 6′ grid line goes right through the chateau.

7.5' grid line going through the Sans Souci Palace in Potsdam, Germany


7.5′ grid line going through the Sans Souci Palace in Potsdam, Germany




The Sans-Souci Palace in Potsdam, Gemany was the royal residence of King Henri I (better known as Henri Christophe) of Haiti, Queen Marie-Louise and their two daughters. It was the most important of nine palaces built by the king, as well as fifteen châteaux, numerous forts, and sprawling summer homes on his twenty plantations.

Here, a 7.5′ grid line goes right through the building.

6' grid line going through the site of the Former Stadtschloss Palace in Berlin, Germany


6′ grid line going through the site of the Former Stadtschloss Palace in Berlin, Germany




The final example is the site of the former Stadtschloss Palace in Berlin, Germany. It was the principal residence (winter residence) of the Hohenzollern Kings of Prussia from 1701 to 1918 (the German Emperors from 1871 to 1918) and a museum following the fall of the German Empire in 1918.

The palace was damaged by Allied bombing in World War II. Although it was possible to repair the palace at considerable expense, it was demolished in 1950 by the German Democratic Republic (GDR) authorities. This was protested greatly by the West Germans. Following the reunification of Germany, it was decided to rebuild the Stadtschloss on the original site.

We can see that a 6′ grid line goes right through the site. Also notice that the same grid line goes through the Berlin Dome, just above the palace.

These are just a small number of examples of the world’s chateaus and palaces there were built on major World Grid lines. Further proof that this knowledge has been available to the world’s elite for hundreds and also thousands of years.

 

Particle Accelerators on the World Grid

September 1, 2011 By Rod Maupin —Leave a Comment 


Recently, we have been looking at Particle Accelerator sites around the world. Perhaps 75% of these sites are on major or minor grid lines. A large majority of them are on major grid lines. Some are on multiple grid lines, both major and minor.

We have found that particle accelerators that have relationships to the World Grid can be broken down into two groups. Those that have a grid line going through the center of the accelerator, and those that have a grid line going through the rim of the accelerator. We have selected one example of each type for you to look at.

The first site is Argonne National Laboratory in Argone, Illinois, USA. Here, a 7.5′ grid line goes through the center of the accelerator ring.

7.5' grid line going through the accelerator ring at Argonne National Laboratory


7.5′ grid line going through the accelerator ring at Argonne National Laboratory




The second example is of Brookhaven National Laboratory in Upton, New York, USA. Here a 6′ grid line goes through the rim of the accelerator ring.

6' grid line going through the rim of the accelerator ring at Brookhaven National Laboratory


6′ grid line going through the rim of the accelerator ring at Brookhaven National Laboratory




We hope this information is both interesting and instructive for you.

 

Article on Gridpoint Atlas 4.0 in Latest Issue of Nexus Magazine

February 4, 2011 By Rod Maupin —Leave a Comment 


Gridpoint Atlas 4.0 article in Nexus Magazine Vol. 18 No. 2
Nexus Magazine Vol. 18 No. 2


Duncan Roads has published a great new article on Gridpoint Atlas 4.0 in the latest issue of Nexus Magazine. The article is written by us, Bruce Cathie and Rod Maupin, and it goes into detail how the Gridpoint Atlas 4.0 software works by itself, and in combination with Google Earth.

Check out this great article in Nexus Magazine!

 

Gridpoint Atlas 4.0 Manual Available for Viewing

January 9, 2011 By Rod Maupin —7 Comments 


Gridpoint Atlas 4.0 Manual

The Gridpoint Atlas® 4.0 manual has just been posted. You can view the manual online or download it for printout.

You will find the manual here.

 

Gridpoint Atlas 4.0 Just Released

June 26, 2010 By Rod Maupin —6 Comments 


Gridpoint Atlas 4.0

The new version of Gridpoint Atlas that works with Google Earth has just been released.

Gridpoint Atlas 4.0 now creates Google Earth-compatible files. You can create a map and overlay the World Grid in Gridpoint Atlas, then view that overlay in Google Earth. For the first time, you will be able to view the World Grid overlaid onto the worldwide satellite imagery of Google Earth.

Whether you call it the World Grid, the Earth grid, the energy grid, the planetary grid, or simply just ley lines, this software plots the grid discovered by Bruce Cathie.

You can now see how all of the world’s ancient sites are related to the grid. Did the ancients know about the grid? Plot it and see.

Order Gridpoint Atlas today!

 

Plot World Grid in Gridpoint Atlas, View in Google Earth

June 23, 2010 By Rod Maupin —Leave a Comment 


Gridpoint Atlas now works with Google Earth. You can overlay the World Grid in the Gridpoint Atlas software, then view the overlay in Google Earth. That’s because Gridpoint Atlas creates Google Earth-compatible KML files.

The following video shows how to overlay the World Grid upon any area of the world, then view the overlay in Google Earth.

Plot the World Grid in Gridpoint Atlas then view in Google Earth
Plot the World Grid in Gridpoint Atlas then view in Google Earth 

 

The Map Window in Gridpoint Atlas

June 23, 2010 By Rod Maupin —Leave a Comment 


There are two windows in the Gridpoint Atlas software. The Calculation window and the Map window.

This video shows how to use the Map window.

The Map Window in Gridpoint Atlas 

The Map Window in Gridpoint Atlas 




 

The Calculation Window in Gridpoint Atlas

June 23, 2010 By Rod Maupin —Leave a Comment 


There are two windows in the Gridpoint Atlas software. The Calculation window and the Map window.

This video shows how to use the Calculation window.

The Calculation Window in Gridpoint Atlas 

The Calculation Window in Gridpoint Atlas 




 

Welcome to World Grid

January 5, 2010 By Rod Maupin —3 Comments 


Thanks for coming to our website. This is the home of Bruce Cathie and the Gridpoint Atlas® software.

We have new pricing for Gridpoint Atlas, check it out on the Order page:

Gridpoint Atlas Order page

Please Note: the screen shots from the Gridpoint Atlas software are not as good as we would like. We will update these as soon as we can.

 

Setting Up Shop

September 20, 2009 By Rod Maupin —9 Comments 


After being at one hosting company for 7 years, we have moved to a new hosting company with more features and options. Please be patient while we get the new site up.

We have new lower pricing for the Gridpoint Atlas software, check it out on the Order page:

Gridpoint Atlas Order page

Please Note: the screen shots from the Gridpoint Atlas software are not as good as we would like. We will update these as soon as we can. We are still trying to get everything updated on this new website, so thanks for your patience.

 


 





Categories
Gridpoint Atlas 
World Grid 


Archives
April 2015
February 2015
January 2015
October 2014
August 2014
July 2014
April 2014
February 2014
December 2013
October 2013
September 2013
June 2013
September 2012
August 2012
July 2012
June 2012
April 2012
February 2012
January 2012
December 2011
October 2011
September 2011
February 2011
January 2011
June 2010
January 2010
September 2009


  


Map the World Grid with Gridpoint Atlas

Home
 Introduction
 ProductsGridpoint Atlas®
 Books and Video
 White Papers
 
 Order
 About UsContact
 FAQ
 World Grid® Consulting Services
 Links
 Terms of Use and Service
 Privacy Policy
 Thank You
 
 


You are here: Home / Order

Order


If you want to place an order, just select one of the options below.

The Gridpoint Atlas software will be shipped from Washington state in the United States. White Papers are downloadable.

If you are outside of the U.S, you should know that we can no longer ship using First Class or Priority Airmail. In the past few years, we have had too many packages not make it to their destination using these methods. We think it’s because of tougher Customs clearing in many countries. Therefore, you will have to pay more for shipping and we are sorry for that.

Note: If you are upgrading and can not find your Serial Number, send an email to gridman@worldgrid.net and we’ll look it up for you.


Please select your product and shipping from the options below:




White Papers (Downloadable Product – available by email immediately after payment)





Mysterious Lights of Marfa and Bragg Road, Texas, USA


Mysterious Lights of Marfa and Bragg Road, Texas, USA

Price: $5.00





Gridpoint Atlas Software – New Customer (Shipped Product)



Please enter Serial Number before pressing
Add to Cart:  


Gridpoint Atlas - New Customer, Inside US, First Class Shipping


Gridpoint Atlas - New Customer, Inside US, First Class Shipping

Price: $171.00




Gridpoint Atlas - New Customer, Inside US, Priority Mail Shipping


Gridpoint Atlas - New Customer, Inside US, Priority Mail Shipping

Price: $172.00




Gridpoint Atlas - New Customer, Inside US, Express Mail Shipping


Gridpoint Atlas - New Customer, Inside US, Express Mail Shipping

Price: $184.00




Gridpoint Atlas - New Customer, Outside US, Express Mail Shipping


Gridpoint Atlas - New Customer, Outside US, Express Mail Shipping

Price: $210.00





Gridpoint Atlas - New Customer, Outside US, GXG FedEx Shipping


Gridpoint Atlas - New Customer, Outside US, GXG FedEx Shipping

Price: $235.00





Gridpoint Atlas Software – Existing Customer (Shipped Product)



Please enter Serial Number before pressing
Add to Cart:  


Gridpoint Atlas - Existing Customer, Inside US, First Class Shipping


Gridpoint Atlas - Existing Customer, Inside US, First Class Shipping

Price: $126.00




Gridpoint Atlas - Existing Customer, Inside US, Priority Mail Shipping


Gridpoint Atlas - Existing Customer, Inside US, Priority Mail Shipping

Price: $127.00




Gridpoint Atlas - Existing Customer, Inside US, Express Mail Shipping


Gridpoint Atlas - Existing Customer, Inside US, Express Mail Shipping

Price: $139.00




Gridpoint Atlas - Existing Customer, Outside US, Express Mail Shipping


Gridpoint Atlas - Existing Customer, Outside US, Express Mail Shipping

Price: $165.00





Gridpoint Atlas - Existing Customer, Outside US, GXG FedEx Shipping


Gridpoint Atlas - Existing Customer, Outside US, GXG FedEx Shipping

Price: $195.00







 


 





Categories
Gridpoint Atlas 
World Grid 


Archives
July 2014
April 2014
February 2014
December 2013
October 2013
September 2013
June 2013
September 2012
August 2012
July 2012
June 2012
April 2012
February 2012
January 2012
December 2011
October 2011
September 2011
February 2011
January 2011
June 2010
January 2010
September 2009


  Service-oriented computing is a popular design methodology for large scale business computing systems. Grid computing enables the sharing of distributed computing and data resources such as processing, networking and storage capacity to create a cohesive resource environment for executing distributed applications in service-oriented computing. Grid computing represents more business-oriented orchestration of pretty homogeneous and powerful distributed computing resources to optimize the execution of time consuming process as well. Grid computing have received a significant and sustained research interest in terms of designing and deploying large scale and high performance computational in e-Science and businesses. The objective of the journal is to serve as both the premier venue for presenting foremost research results in the area and as a forum for introducing and exploring new concepts.

Authors are solicited to contribute to this Open Access peer-reviewed Journal by submitting articles that illustrate research results, projects, surveying works and industrial experiences that describe significant advances in the following areas, but are not limited to

Topics of interest include but are not limited to, the following

    Applications, including eScience and eBusiness Applications
    Architectures and Fabrics
    Distributed and Large-Scale Data Access and Management
    Core Grid Infrastructure
    Peer to Peer Protocols in Grid Computing
    Network Support for Grid Computing
    Monitoring, Management and Organization Tools
    Networking and Security
    Performance Measurement and Modelling
    Metadata, Ontology, and Provenance
    Middleware and toolkits for Grid Computing
    Computing and Programming Models
    Programming Tools and Environments
    Distributed Problem Solving
    Creation and Management of Virtual Enterprises and Organizations
    Information Services
    Resource Management, Scheduling, and Runtime Environments
    Scientific, Industrial and Social Implications
    QoS and SLA Negotiation
    Grid Economy and Business Models
    Autonomic and Utility Computing on Global Grids
    Cluster and Grid Integration Issues
    Web Services, Semantic Grid and Web 2.0
    Grid related ApplicationImplementation of Strong Mobility for Multi-Threaded Agents in Java
Arjav J. Chakravarti Xiaojin Wang Jason O. Hallstrom Gerald Baumgartner
Department of Computer and Information Science
The Ohio State University
Columbus, OH 43210, USA
{arjav,hallstro,gb}@cis.ohio-state.edu frozen wang@hotmail.com
Abstract
Strong mobility, which allows multi-threaded agents to
be migrated transparently at any time, is a powerful mechanism
for implementing a peer-to-peer computing environment,
in which agents carrying a computational payload
find available computing resources. Existing approaches to
strong mobility either modify the Java Virtual Machine or
do not correctly preserve the Java semantics when migrating
multi-threaded agents.
We give an overview of our implementation strategy for
strong mobility in which each agent thread maintains its
own serializable execution state at all times, while thread
states are captured just before a move. We explain how to
solve the synchronization problems involved in migrating a
multi-threaded agent and how to cleanly terminate the Java
threads in the originating virtual machine. We present experimental
results that indicate that our implementation approach
is feasible in practice.
1 Introduction
The advent of Grid Computing [9] has improved the reliable
utilization of shared computational resources for the
solution of complex problems, such as for [13]. Peer-to-
Peer systems adopt a highly decentralized, though less reliable,
approach to resource sharing, and are mainly used
for embarrassingly parallel applications like [27] and simple
applications like file-sharing [11]. A confluence of these
two technologies will facilitate the building of flexible systems
to support dynamic communities of users [15, 8].
The vast majority of distributed applications are currently
built with distributed object technologies, such as
Java RMI, CORBA, COM, or SOAP. These RPC-based approaches
do not, however, consider the execution state of
their arguments. If a thread is active within one of the arguments
passed to a remote procedure, it does not travel along
with the argument.
The Mobile Agent abstraction is the movement of code,
data and threads from one location to another [19]. In the
peer-to-peer applications envisaged for Grid systems, mobile
agents offer a flexible means of distributing data and
code around a network, of dynamically moving between
hosts as resources become available, and of carrying multiple
threads of execution to simultaneously perform computation,
the scheduling of other agents, and communication
with other agents on a network. Approaches to using
mobile agents for Grid Computing have been discussed in
[4, 24, 22].
Java is the language of choice for an overwhelming majority
of the mobile agent systems that have been developed
until now. However, the execution model of the Java Virtual
Machine does not permit an agent to access the run-time
stack and program counter.
A ramification of this constraint is that Java based mobility
libraries can only provide weak mobility [6]. Weakly
mobile agent systems, such as IBM’s Aglets framework
[20] do not migrate the execution state of methods. The
go() method, used to move an agent from one virtual machine
to another, simply does not return. The agent environment
kills the threads currently executing in the agent,
without saving their state. The lifeless agent is then shipped
to its destination and is resurrected there. Weak mobility
forces programmers to use a difficult programming style,
i.e., the use of callback methods, to account for the absence
of migration transparency.
By contrast, agent systems with strong mobility provide
the abstraction that the execution of the agent is uninterrupted,
even as its location changes. Applications that require
agents to migrate from host to host while communicating
with one another to solve a problem, are severely
restricted by the absence of strong mobility. The ability of
a system to support the migration of an agent at any time
by an external thread, is termed forced mobility. This is
particularly useful for load-balancing, and for fault-tolerant
applications, and is difficult to implement without strong
mobility. Strong mobility also allows programmers to use a
far more natural programming style.
A number of different approaches have been followed to
1
add strong mobility to Java. These can be separated into two
broad categories - those that use modified or custom VMs,
and those that change the compilation model.
JavaThread[3], D’Agents[12], Sumatra[1], Merpati[28]
and Ara[23], all depend on extensions to the standard VM
from Sun, whereas the CIA[16] project uses a modification
of the Java Platform Debugger Architecture. Forced mobility
is not supported by JavaThread, CIA and Sumatra. In
addition, JavaThread depends on the deprecated stop()
method in java.lang.Thread to migrate an agent. The
D’Agents, Sumatra, Ara and CIA systems do not migrate
multi-threaded agents. Merpati does not migrate agent
threads that are blocked in monitors. The NOMADS[29]
project uses a custom virtual machine known as Aroma, to
provide support for forced mobility and the migration of
multi-threaded agents. Support for thread migration within
a cluster is provided by JESSICA2[32]. The solution does
not scale to the Internet or a Grid, however, because a distributed
VM is used.
Modifying the Java VM, or using a custom VM, has the
major disadvantage of a lack of portability. Existing virtual
machines cannot be used. It is very difficult to maintain
complete compatibility with the Sun Java specification. For
example, JavaThread and NOMADS are JDK 1.2.2 compatible,
D’Agents relies on a modified Java 1.0 VM, and
Merpati and Sumatra are no longer supported. It is also
difficult to achieve the performance of the JVM from Sun.
NOMADS, Sumatra andMerpati do not support JIT compilation.
In addition, some users may prefer to use other VMs
of their choice. These problems greatly impact the acceptability
and widespread use of mobile agent systems that rely
on VM modifications.
Another approach to adding strong mobility to Java is
to change the compilation model (by using a preprocessor,
by modifying the compiler, or by modifying the generated
bytecode) such that the execution state of an agent can be
captured before migration.
This approach is followed by WASP[10] and
JavaGo[26]. These use a source code preprocessor.
However, neither supports forced mobility. In addition,
JavaGo does not migrate multiple threads of execution
or preserve locks on migration. Correlate[30] and
JavaGoX[25] modify bytecode. Migration may only be
initiated by the agent itself, i.e., forced mobility is not
supported.
We have chosen to provide strong mobility for Java by
using a preprocessor to translate strongly mobile source
code to weakly mobile source code [5, 31]. We present
an overview of our implementation approach, in which an
agent maintains a movable execution state for each thread
at all times. The generated weakly mobile code saves the
state of a computation before moving an agent so that the
state can be recovered once the agent arrives at the destination.
The code translation could be done at the level of
bytecode as well. The translation of method calls requires
type information, however, and this would involve decompiling
bytecode. To avoid this, we use the more convenient
source translation mechanism.
Jiang and Chaudhary [18, 17] use a similar approach for
C and C++. The scalability of their system is limited by
its dependence on a global scheduler to migrate threads. It
is also unclear whether they can handle multiple concurrent
migrations, which could impact performance. Bettini and
De Nicola [2] also use the same idea for agent migration,
but they do this for a toy language. Our implementation is
designed for the full Java programming language.
2 Overview
Our implementation approach for strong mobility in Java
is to translate strongly mobile code into weakly mobile
code. We currently target the IBM Aglets weak mobility
system.
Every method in the original agent class is translated to
a Serializable inner class which represents the activation
record for that method. The local variables, parameters
and program counter are converted to fields of this class.
This inner class contains a run() method to represent the
body of the original method. The generated weakly mobile
agent class contains an array of activation record objects
that acts as a virtual method table.
Threads in Java are not Serializable because they
use native code. However, the state of every thread of execution
also needs to be maintained so that the thread can
be restarted at the destination. This is achieved by using a
Serializable wrapper around each Java Thread. This
wrapper contains its own stack of activation records that
mirrors the run-time stack of the underlying thread of execution.
When a method is called, the appropriate entry from
the method table is cloned and put on the stack. Its run()
method is then executed.
Statement execution and the program counter update
should be executed atomically to allow an agent to be
moved at arbitrary points of time. The original source code
is translated to a form that allows the state of the agent to
be saved for each executed statement, while maintaining the
semantics of these statements. Translation rules for the different
types of statements in the Java language are required.
A go() method is called on a multi-threaded agent to send
it to a new location. The Serializable wrappers then
bring the agent threads to a standstill and save the state of
these threads. The agent then relocates and carries along
with it only the Serializable wrappers of the threads.
These wrappers create new Thread objects at the destination
and recreate their execution state. Potentially longrunning
operations like Object.wait(long) are inter-
2
rupted and the time left for them to finish execution is saved
before the move.
The use of multi-threaded agents makes synchronization
issues very important. For a multi-threaded system,
the program counter must be incremented atomically with
the following instruction; two agents must not dispatch
one another at the same time, and two threads within the
same agent must not dispatch the agent simultaneously.
User-specified synchronized blocks in the original Java
source code also need to be translated so that they can be
carried along by an agent. Synchronization control in mobile
agents is non-trivial, but we offer an approach that is no
more taxing than programming for a traditional non-mobile
system.
Each statement and its corresponding program counter
update are wrapped inside a logical synchronized block to
preserve their atomicity and prevent agent relocation before
their completion. It is unacceptable for the implementation
to synchronize on the agent instance because that would
prevent threads from executing translated statements in parallel.
The problem is a basic readers/writers conflict, where
the threads that execute the translated statements are readers,
and the thread that executes the go() method acts as
a writer. A writers priority solution is used. Each agent
maintains locks that represent the predicate, ‘OK to execute
statements?’. The number of locks is the same as the
number of reader threads, and are acquired and released by
readers before and after statement execution. When a call
is made to go(), the writer thread acquires all the locks,
saves the agent state and moves the agent to a new site.
The call to go() is synchronized on the agent context
instead of on the caller, in order to prevent deadlock when
two agents call one another. Similarly, if multiple threads
within the same agent attempt to move the agent, deadlock
is prevented by having each thread test a synchronized condition
variable in the agent context. The first writer thread
will set this variable, and the subsequent writers will test the
variable and then give up their locks.
Threads must acquire and release a lock on a particular
object on entering and leaving a synchronized block.
If an agent moves when a thread is executing inside this
protected region, the lock held by the thread is released.
Protection is extended across machine boundaries by introducing
serializable locks in place of standard Java locks, for
every object that is synchronized upon. synchronized
blocks are often used in conjunction with the wait() and
notify() operations. These too, are appropriately translated
to preserve their semantics.
We have run a number of benchmarks to test our translator
for strong mobility. A comparison of the performance
of the translated agents and the corresponding IBM Aglets
has been performed. Some simple optimizations to the generated
code were performed by hand, and the performance
enhancement was observed. The measurements confirm the
feasibility of our approach.
3 Language and API Design
Our support for strong mobility consists currently of the
interface Mobile and the two classes MobileObject
and ContextInfo.
3.1 Interface Mobile
Every mobile agent must (directly or indirectly) implement
the interface Mobile. A client of an agent must access
the agent through a variable of type Mobile or a subtype
of Mobile.
Interface Mobile is defined as follows:
public interface Mobile extends
java.io.Serializable {
public void go(java.net.URL dest)
throws com.ibm.aglet.RequestRefusedException,
edu.ohio_state.cis.brew.MoveRefusedException,
java.io.IOException; ... }
Like Serializable, interface Mobile is a marker
interface. It indicates to a compiler or preprocessor that
special code might have to be generated for any class implementing
this interface. go() moves the agent to the
destination with the URL dest. This method can be called
either from a client of the agent or from within the agent
itself. The second parameter indicates whether the call was
made from within the agent or from outside.
3.2 Class MobileObject
Class MobileObject implements interface Mobile
and provides the two methods getContextInfo() and
go(). To allow programmers to override these methods,
they are implemented as wrappers around native implementations
that are translated into weakly mobile versions.
A mobile agent class is defined by extending class
MobileObject.
The method getContextInfo() provides any information
about the context in which the agent is currently running.
3.3 Class ContextInfo
Class ContextInfo is used for an agent to access any
resources on the machine it is currently running on, including
any system objects that the host wants to make accessible
to a mobile agent.
Currently, we only provide a method getHostURL(),
that returns the URL of the agent environment in which the
agent is running. We will extend the functionality of class
ContextInfo in future translator versions.
For providing access to special-purpose resources such
as databases, an agent environment can implement the
method getContextInfo() to return an object of a subclass
of class ContextInfo.
3
3.4 Strongly Mobile User Code
For writing a mobile agent, the programmer must first
define an interface, say Agent, for it. This interface should
extend interface Mobile and declare any additional methods.
All additional methods must be declared to throw
AgletException. An implementation of the mobile
agent then extends class MobileObject and implements
interface Agent. A client of the agent must access the
agent through a variable of the interface type Agent and
through a proxy object similar as in Java RMI or in Aglets.
4 Translation from Strong toWeak Mobility
In this section, we present the translation mechanism for
methods, classes, statements, and exceptions.
4.1 Translation of Methods
For each agent method, the preprocessor generates a
class whose instances represent the activation records for
that method. As multiple invocations may be active simultaneously
(e.g., recursive methods), these objects are cloneable.
An activation record class for a method is a subclass
of the abstract class Frame.
public void foo(int x) throws AgletsException {
int y;
// blocks of statements
BC1
BC2 }
The parameter x, local variable y and the program
counter become fields of class Foo. A setPCForMove()
method is necessary to allow the arbitrary suspension and
movement of a thread of execution. This method saves
the current programCounter, before setting it to -1 to
ensure that no further instructions get executed before the
agent moves. The run() method contains the translated
version of the body of foo(), which includes code for
incrementing the program counter, as well as code which
allows run() to resume computation after a move. Every
thread needs to poll whether it is time to move or not.
It does this by acquiring and releasing a lock before and
after every logical statement in the code. This is done
by the AgentImpl.this.request_read() and
AgentImpl.this.read_accomplished() calls.
The generated activation record class for foo is:
protected class Foo extends Frame {
int x, y, progCounter = 0; Object trgt;
void setPCForMove() { ... }
void run() {
try { ...
AgentImpl.this.request_read();
if ((progCounter == 0)) {
progCounter+=1; BC1 }
AgentImpl.this.read_accomplished();
AgentImpl.this.request_read();
if ((progCounter == 1)) {
progCounter+=1; BC2 }
AgentImpl.this.read_accomplished(); }
catch(AgletsException e) { ... }} ... }
4.2 Translation of Agent Classes
The generated agent class contains an array of Frame
objects that is used as a virtual method table. When a
method is called, the appropriate entry from the method table
is cloned and put on the thread wrapper stack.
For example, suppose that we have an agent class
AgentImpl of the form:
public class AgentImpl extends
MobileObject implements Agent {
int a; public AgentImpl() {/* init code */}
public void foo(int x) throws AgletsException {
BC; } }
Because this class (indirectly) implements the Mobile
interface, the preprocessor translates it into the code described
below:
The original agent method foo() gets translated into
an inner class Foo. There are two foo() methods in the
generated code, of which foo(Object, Object) is a
preparatory method. Its first parameter is a reference to the
wrapper of the thread on which the method is to be executed.
An activation record is created and pushed onto the
wrapper stack. The second parameter is an Object array
that contains the arguments to the original foo() method.
These are given to the activation record.
The second foo() method has the same order, type and
number of parameters as the original untranslated method.
All the calls to the original foo method from within the
agent now go to this method. The method obtains a reference
to the wrapper of the currently executing thread and
packages its parameters in an Object array, before calling
the foo(Object, Object) method described above.
The activation record on the top of the stack is then executed.
public void foo(Object target, Object init){...}
public void foo(int x) { ...
//fooThread - wrapper of current thread
foo(fooThread,
new Object[]{new Integer(x), ... });
//method call to execute original method body
fooThread.run1(); return; }
The Aglets system does not allow method invocations
from outside the agent, only message sends. The
handleMessage() method is an Aglets method that receives
messages sent to the agent. If the foo() method
in the untranslated agent could be invoked by an external
thread, a new thread is created when a message is received
for foo(). foo(Object, Object) is then called and
the activation record on top of the stack is executed.
public boolean handleMessage(Message msg) {
if (msg.sameKind("foo")) { ...
// fooThread is the wrapper of the new thread
foo(fooThread, msg.getArg());
fooThread.start(); ... return true; } ... }
4
Our translator translates almost the entire Java language.
Some portions of the translator have not been implemented
completely due to time constraints. The mobility translator
is a preprocessor to the Brew compiler. The compiler
is still under development, and as yet does not do typechecking.
For this reason, it needs to be hard-coded into
the translator as to whether method calls and returns are to
targets outside or within the agent. The translation of inner
classes, try blocks, labels, and the assert, break
and continue statements has not yet been implemented.
Name-mangling to support nested blocks and overloaded
methods, and the translation of method calls inside expressions
also need to be completed. We believe that these issues
are simple enough to be satisfactorily resolved.
5 Resource Access
When accessing global resources it is desirable to distinguish
between global names on the current virtual machine
and global names on the home platform of the agent. To
allow agent developers to access platform-bound resources
remotely, we introduce the global field declaration prefix.
Use of the prefix indicates that a particular field should be
created (and accessed) on the home platform. For example:
private global InputStream is;
For each field prefixed with the global keyword, the
preprocessor generates code to register an RMI server with
the home platform. Each RMI server is a simple wrapper,
delegating calls to the original field instance, to which it
maintains a reference. Special accessor methods are also
provided by these servers to handle field assignment, scalar
field access, and access to field members within a global
field. These field servers are created and registered immediately
after the agent is constructed. Any agent code that
accesses the global field is translated to access the resource
through the corresponding RMI proxy.
A similar problem arises when examining accesses
to fields and methods which are both public and static.
Consider, for example, an agent that wishes to roughly
approximate the time it takes for it to move between
two platforms. The agent needs to access the method
System.currentTimeMillis() from the home platform.
To provide agent developers flexibility in specifying
whether access to a static method or field refers to the home
VM, we introduce syntax for retroactively making a static
method or field global. By default, access to a static method
or field will refer to the VM on which the agent currently resides.
To indicate that the home VM should be used to perform
the access, we use a retroactive global declaration
as follows:
global long System.currentTimeMillis();
global PrintStream System.out;
The implementation of remote resource access has not
yet been completed.
6 Multi-Threaded Agents
The multi-threading support provided by Java consists of
the classes Thread and ThreadGroup and the interface
Runnable, which allow us to create multiple threads of
execution within the agent, and to manage groups of threads
as a unit.
Java Threads are not serializable because they involve
native code. The state of each thread needs to be saved in a
serializable format that can then be relocated.
6.1 MobileThread and MobileThreadGroup
The serializable wrapper classes MobileThread and
MobileThreadGroup, are used around the Java library
classes Thread and ThreadGroup. When
MobileThread and MobileThreadGroup objects are
created, they create new Thread and ThreadGroup objects
to perform the actual execution. MobileThread
thus contains the information about its underlying thread
that is needed to reconstruct the state of that thread after
a move. MobileThreadGroup acts similarly with respect
to ThreadGroup. Only the wrappers are moved
when an agent moves to a new site. At the destination,
these wrappers create new Thread and ThreadGroup
objects and set their state so that execution can continue.
Each MobileThread also belongs to a particular
MobileThreadGroup, and when a MobileThread
object recreates a thread of execution, that Thread is also
assigned to the same ThreadGroup as at the source location.
The class MobileThread contains a start()
method which is called to begin execution of a
MobileThread. This can happen after it has been created
for the first time or when the agent starts up all the threads
after moving to a new site. This method calls the start()
method of the underlying Thread, which then calls the
run() method of its target, the MobileThread wrapper.
The run() method checks the MobileThread stack. If
the stack is empty, it means that the MobileThread is a
newly created one, and has to call the run() method of its
Runnable target. The MobileThread’s stack not being
empty means that the activation records already on the
stack need to be executed.
The preprocessor translates the strongly mobile agent
code to weakly mobile code, as explained in Section 4.
Furthermore, the preprocessor replaces every occurrence
of Thread and ThreadGroup in the original code with
MobileThread and MobileThreadGroup. In this
manner, every reference to a Thread or ThreadGroup
object in the original code is now translated to a reference
to a MobileThread or MobileThreadGroup object.
We thus ensure that every original operation on a Thread
or ThreadGroup in user code is now made to go through
their wrappers.
5
The mobility translator translates every occurrence of
the word Thread in the source code with the word
MobileThread. This ensures that the calls to the methods
of Thread go through the serializable wrapper, and
that the run() method of a multi-threaded Agent now executes
as activation records on the stack of the thread wrapper.
6.2 Static Methods of java.lang.Thread
When MobileThread.currentThread() is
called, it calls Thread.currentThread() in turn.
This returns a reference to the currently executing Thread.
A reference to the MobileThread wrapper over this
Thread object now needs to be returned. The solution is
to maintain a static Hashtable that contains a mapping of
Threads to their corresponding MobileThreads. In
this way, MobileThread.currentThread() returns
the correct MobileThread object.
Similarly, the other static methods of MobileThread
(sleep(), enumerate(), etc.) use ThreadTable,
where necessary, to return the appropriate
MobileThread references.
6.3 Relocating a Multithreaded
Agent
The go() method is called on a multi-threaded agent.
This calls the realGo() method, which first checks
whether this agent is already being moved or not. If the
agent is being moved, a MoveRefusedException is
thrown. Otherwise, the thread that wishes to move the agent
acquires locks such that every Thread within the agent
blocks and comes to a standstill. Each MobileThread
makes an interrupt() call to its Thread, thus terminating
any wait(), join() or sleep() operations. If
any of these are timed, the time remaining for them to finish
is saved such that they can be completed at the destination.
The packUp() method of the main agent threadgroup
wrapper is called. From here, the packUp() method of
each threadgroup and thread wrapper under main is called,
and the state of its underlying threadgroup and thread
saved. The system threads are then forced to terminate and
the agent is relocated by using the Aglets dispatch()
method. The java.lang.Thread API does not permit
direct termination of a thread. Section 7 explains how we
accomplish this.
On arrival at the destination, the reinit() method of
the main threadgroup wrapper is called. This method then
creates a new ThreadGroup, sets its state, and then calls
the reinit() method of each threadgroup and thread
wrapper under main. Each wrapper’s reinit() method
creates a new Thread or ThreadGroup, and sets its
state. The start() method of the main threadgroup
wrapper is called, resulting in calls to the start() methods
of all MobileThreads to begin execution of their
threads.
7 Synchronization Issues
There are three major issues that need to be handled correctly
for the synchronization control of a multi-threaded
agent - preserving the atomicity of a logical instruction;
preventing deadlock when agents dispatch one another,
or when multiple threads attempt to dispatch the agent;
preserving the semantics of Java synchronized blocks
across a migration.
7.1 Protection of Agent Stacks
An agent should not be moved while it is executing a
statement. It is necessary to protect every program counter
increment and its following statement. Synchronizing on
the agent will reduce parallelism dramatically. The problem
can be reduced to a basic readers/writers conflict, where the
increment of the program counter, and the execution of the
following statement by each thread, acts as a reader; the
writer being the thread that calls go(). This problem is
solved by using a variant of the solution in [14]. Locks
are maintained by each agent. The predicate they represent
is ‘OK to execute statements?’. The number of locks
equals the number of executing threads within the agent.
Reader threads acquire and release locks before and after
executing logical statements, by request_read() and
read_accomplished() calls.
AgentImpl.this.request_read(); if(pc==15) {pc++;
stmt;} AgentImpl.this.read_accomplished();
When a thread makes a call to go(), it is designated as
a writer. The writer thread attempts to acquire all the agent
locks. Once it makes this attempt, no reader can acquire a
lock. The writer then calls interruptForMove() on
all currently executing MobileThreads. If a thread is
carrying out a wait(), join() or sleep(), the wrapper
repeatedly interrupts it until it stops the operation. The
method whose execution was interrupted, checks whether
the wrapper interrupted the thread. If so, the program
counter is decremented so that the interrupted operation
will resume at the destination. If the interrupted operation
was timed, like wait(long), the time remaining for the
operation to complete is saved by the MobileThread.
An InterruptedException is thrown if the wrapper
did not cause the interrupt. A count of the number
of currently active readers is maintained. This count is
incremented when a reader requests the lock by calling
request_read(), and decremented when the lock is released
by a read_accomplished() call. As the readers
only relinquish their locks at this stage, depending on
whether the writer is an internal or an external thread, the
count must go down to one or zero. The writer then calls
the packUp() method of the main threadgroup wrapper.
This results in each MobileThread saving the state of
its Thread, setting the program counter of the activation
records on its stack to -1, and disallowing the popping of activation
records. At this point, the writer releases its locks.
6
All the waiting readers are released and are free to continue
execution. The program counters have all been set to a negative
value, however, and so no further statements can be
executed. The reader threads run through to completion and
terminate. None of the activation records are popped during
this step.
It is necessary to ensure that all the threads that were executing
wait() and join() operations at the source are
restored to their original condition at the destination before
the other agent threads are restarted.
Extending the guarantee of transparent interruption and
restoration of long-running operations to library code, is
non-trivial. Libraries may implement guarded wait()s,
sleep()s or join()s by using loops with condition
checks around these operations; an approach similar to that
described in [21]. When a MobileThread interrupts its
Thread, its held locks would not be released immediately
in this case. Agent relocation would be delayed, perhaps for
an unacceptable amount of time.
We believe that most calls to the standard Java library
will terminate within an acceptable amount of time. In the
absence of a mechanism that can save the state of a Thread
executing a library call, the best option is for the compiler
to flag library calls that could lead to potentially long operations
and indicate that no guarantee about the immediate
migration of an agent is possible. A message could
be printed out to the programmer and the decision would
have to be taken by him/her as to whether the delay in migration
would be acceptable. Should the programmer desire
a finer granularity of control, he/she should pass the
library through the mobility translator. Another possibility
would be to implement native code wrapper methods
around wait(), sleep() and join(), thus allowing a
MobileThread to detect and interrupt its Thread’s long
operations. This would have to be at the bytecode level.
If two agents try to dispatch one another, the synchronization
technique we have adopted could lead to a deadlock.
Agent a would synchronize on itself for executing the
statement b.go(dest), which would require synchronization
on b to protect the integrity of b’s stacks. If similarly,
b would execute a.go(dest), a deadlock would
result. To prevent this, the call of dispatch() within
realGo() is synchronized on the agent context instead of
on the caller.
When two agents try to move one another, and a executes
b.go(dest) and b executes a.go(dest), each
Aglet sends a go message to the other. If a’s go() method
synchronizes on the agent context first, every thread inside
a is interrupted before a move. This includes the thread that
is attempting to move b. All of a’s threads get interrupted,
a’s state is saved, and a is moved to its destination. Since
a’s attempt to move b is interrupted, b does not move.
If multiple threads within the same agent attempt to
move the agent, deadlock could still result. More than one
thread could call go(). Only one of them will actually
synchronize on the agent context. Now, when this writer
thread attempts to acquire all the locks, it will not be able
to. This is because the other threads that are attempting to
move the agent will be blocked, waiting to acquire a lock on
the agent context. An additional level of synchronization is
introduced in order to avoid this. Every agent maintains
a condition variable in the agent context. This indicates
whether the agent is currently being moved or not. The first
writer thread will acquire a lock on this variable, test and
set it, and then release the lock. Subsequent threads will acquire
the lock, test the variable, and then release the lock by
throwing a MoveRefusedException.
7.2 Synchronization Blocks
The Java semantics for synchronized blocks or
methods are that the locks acquired by a thread on entering
them are released when the agent is migrated. When
users use synchronization to protect the agents’ internal
data structure, this protection must extend across machine
boundaries.
For weakly mobile languages, synchronized blocks are
a non-issue since code never executes beyond the call to
go(). In strongly mobile systems, however, a call to go()
may appear at any point within a synchronized block.
Difficulties stem from the fact that object locks are
not stored within the object during serialization, but are
hidden within the virtual machine. To tackle this problem
we introduce serializable locks in place of standard
Java object locks. Client programmers use the standard
synchronized keyword to enforce synchronization
constraints. During the translation phase, an object
of class MobileMutex is introduced for each object
that requires synchronization. Whenever a programmer
requests object locking through the use of the Java
synchronized keyword, the lock is actually taken out
and released via calls to lock() and unlock() on the
associated MobileMutex object. In this way, synchronized
blocks and methods are eliminated from the original
source, and re-implemented using the new locking mechanism.
The overhead is minimal, and synchronization semantics
are preserved across a move.
synchronized blocks are often used in conjunction
with wait() and notify() operations. These are translated
such that their semantics are preserved even after the
translation of synchronized blocks.
If synchronized blocks are to be made transparent across
moves, a MobileMutex object needs to be added to the
object on which synchronization is desired. In our current
implementation, this is only possible if the programmer has
access to the source code of that object, if the object is itself
an agent, or if the programmer has source access to
7
every synchronization on the object. In the next version
of the translator, we will address this issue by associating a
MobileMutex object with every java.lang.Object.
8 Performance
8.1 Optimizations
The translation mechanism discussed do far is overly
conservative and thus inefficient. We have identified some
optimizations for the above translation algorithms that are
simple enough to be done automatically by a compiler:
• If a method is not recursive, or if it is tail-recursive and
the compiler can determine that the execution time is
bounded, it should not be translated into a class.
• To reduce the overhead of synchronization and program
counter update, statements should be grouped to
form logical, atomic statements.
• If the number of statements executed inside a loop is
sufficiently small, and the statements are simple, i.e.,
no method calls or loops, a lock acquire and release
could be made every N (say 10,000) simple statements.
This would mean that in the case of a go() call, upto
N statements would need to be executed before the
move actually takes place.
• Loop unrolling and method inlining could reduce overhead.
• If a local variable is limited in scope to only one logical
statement, it should remain a local variable, and should
not be translated into a field of the generated class.
• Code that checkpoints every N simple statements, or
every N milliseconds could be generated.
8.2 Measurements
Measurements were taken to estimate the cost of the described
translation mechanism for agents. Standard Java
benchmarks were rewritten in the form of both strongly mobile
agents and Aglets. This did not involve changing the
timed code significantly. The only changes that needed to
be made to the original benchmarks’ code were made to
avoid method calls inside expressions. This is because the
preprocessor does not as yet handle these.
The strongly mobile agents were passed through the
translator. We then used simple manual optimization techniques
to improve the performance of the translated agents.
These are - the grouping of simple statements to form logical,
atomic statements; the obtaining and releasing of locks
every 10,000 simple statements for a loop; the inlining of
Benchmark Translated Optimized
Code Code
Crypt(array size - 3000000) 5.61X 1.23X
Crypt(array size - 3000000) 5.96X 1.30X
multi-threaded version - 1 thread
Crypt(array size - 3000000) 6.00X 1.41X
multi-threaded version - 2 threads
Crypt(array size - 3000000) 5.60X 1.31X
multi-threaded version - 5 threads
Linpack(500 X 500) 10.00X 1.75X
Linpack(1000 X 1000) 9.48X 1.65X
Tak(100 passes) 245.30X 220.83X
Tak(10 passes) 247.00X 213.60X
Simple Recursion 68.27X 60.75X
(sum of first 100 natural nos. -
10000 passes)
Table 1. Execution time of Strongly Mobile
Agents compared to corresponding Aglets
Benchmark Translated Optimized Aglet
Code Code
Crypt 32.10 30.69 30.44
Crypt - multi-threaded 32.54 30.82 30.35
1 thread
Crypt - multi-threaded 32.56 30.82 30.35
2 threads
Crypt - multi-threaded 32.54 30.83 30.38
5 threads
Linpack(500 X 500) 31.02 30.02 28.34
Linpack(1000 X 1000) 58.27 52.94 51.24
Tak(100 passes) 22.04 21.99 20.98
Tak(10 passes) 22.05 22.02 20.98
Simple Recursion 22.03 21.82 21.02
Table 2. Memory utilization of Strongly Mobile
Agents and Aglets (MB)
method calls to simple methods that in turn, do not contain
method calls.
The running times and memory footprints of the translated
agents and the manually optimized agents were compared
with the equivalent weakly mobile Aglets. The results
have been presented in table 1, and in table 2. A major contributor
to the poor running times of the recursive benchmark
programs is the Garbage Collector which runs several
times a second.
We performed some further optimzations on the Linpack
benchmark. The time taken by Linpack depends to a great
extent on a particular method call inside a double-nested
loop. This method contains another loop. We manually
inlined this method, and measured execution time with the
inner-most loop untranslated, and with the translated loop
unrolled. The running time comparisons are presented in
table 3, and the memory footprint results are in table 4. A
user could obtain a performance improvement by including
annotations in the code to inform the preprocessor how to
optimally translate certain code portions.
A comparison of the code sizes of the agent code out-
8
Linpack Inner Loop Inner Loop Inner Loop
Optimizations Untranslated Unrolled Unrolled
2 times 10 times
Linpack 1.02X 1.21X 0.75X
(500 X 500)
Linpack 1.02X 1.15X 0.76X
(1000 X 1000)
Table 3. Execution time of Optimized Strongly
Mobile Agents compared to corresponding
Aglets for Linpack
Linpack Inner Loop Inner Loop Inner Loop
Optimizations Untranslated Unrolled Unrolled
2 times 10 times
Linpack 29.9 30.19 30.48
(500 X 500)
Linpack 52.8 53.12 53.40
(1000 X 1000)
Table 4. Memory utilization of Optimized
Strongly Mobile Agents for Linpack (MB)
put by the preprocessor, and that of the corresponding simple
Aglets, was made for the benchmarks discussed above.
This was done by comparing their .class files. For the
benchmarks discussed previously, the translated agents are
between 6 and 14 times the sizes of the simple Aglets.
The overhead of migrating agents depends on the amount
of state that the agent requires to carry along with itself.
This is dependent on the number of threads within the agent,
and on the number of frames on the runtime stack of the
threads. The migration costs of moving a single threaded
agent with different numbers of frames on the stack have
two components - the time required to pack up the agent
state, and the time to move the agent. The latter is the time
required for the translated agent to execute the Aglets dispatch
method. We compare this against the time required
for the transfer of the simple benchmark Aglet. Agents
and Aglets are transferred between ports on the same machine,
in order to obtain a meaningful comparison that is
unaffected by network delay. The results for different stack
sizes are shown in table 5.
Similarly, the dependence of the migration cost of a
multi-threaded agent, on the number of threads is shown
in table 6.
The measurements were taken on a Sun Enterprise 450
(4 X UltraSPARC-II 296MHz), with 1GB of main memory,
running Solaris. We used the Sun JDK 1.4.0 01 HotSpot
VM in mixed mode execution, with the heap size limited to
120MB.
9 Conclusions
We have argued that strong mobility is an important abstraction
for developing Grid Computing applications, and
have outlined a source translation scheme that translates
Number of Agent Agent Aglets
stack frames pack time dispatch time dispatch time
1 6 2436 1750
2 5 5421 1875
3 5 5410 1830
Table 5. Migration Time for Singlethreaded
Strongly Mobile Agents and Aglets (ms) Linpack
Number of Agent Agent Aglets
threads pack time dispatch time dispatch time
1 9 5266 1782
2 10 5133 1860
5 16 5126 1803
Table 6. Migration Time for Multithreaded
Strongly Mobile Agents and Aglets (ms) 5
frames on main thread stack, 2 frames on
other threads’ stacks Multithreaded
Crypt
strongly mobile code into weakly mobile code by using a
preprocessor. The API for the strongly mobile code and the
translation mechanism are designed to give programmers
full flexibility in using multi-threaded agents, and in dealing
with any synchronization problems.
We are able to handle almost the entire Java programming
language. Time constraints mean that the translation
of some constructs like inner classes, and try blocks
have not yet been implemented. If an agent uses library
code that contains guarded wait, sleep or join calls,
rapid termination before a move cannot be guaranteed.
synchronized blocks that synchronize on an untranslated
Object in user code cannot be transparently migrated.
In both these situations, the translator is designed to display
a warning for the programmer. Some resources need
to be accessed on the machine where the agent originated,
and should be declared global by the programmer. An
RMI server to do this needs to be implemented. Timed operations,
like open network connections, are not preserved
across a relocation. Mobile agents need to be prevented
from sharing objects with one another, or non-mobile objects.
We will investigate using Isolates [7] for this purpose.
Source code, rather than bytecode translation, does not
involve decompilation, and is more convenient. The performance
measurements indicate that our approach to achieving
strong mobility for Java is practical. In future, we will
use analysis techniques to automate the generation of optimized
source code. Measurements also indicate that performance
can be improved further by allowing programmers
to make annotations to source code.
Our preprocessor currently generates Java code that uses
IBM’s Aglets library. In future versions of our translator,
we will instead target the ProActive weak mobility system,
or RMI directly.
9
References
[1] A. Acharya, M. Ranganathan, and J. Saltz. Sumatra: A
Language for Resource-Aware Mobile Programs. In Mobile
Object Systems: Towards the Programmable Internet, number
1222 in Lecture Notes in Computer Science. Springer-
Verlag, 1996.
[2] L. Bettini and R. D. Nicola. Translating Strong Mobility into
Weak Mobility. In Mobile Agents, pages 182–197, 2001.
[3] S. Bouchenak, D. Hagimont, S. Krakowiak, N. D. Palma,
and F. Boyer. Experiences Implementing Efficient Java
Thread Serialization, Mobility and Persistence. Technical
Report RR-4662, INRIA, December 2002.
[4] J. Bradshaw, N. Suri, A. J. Caas, R. Davis, K. M. Ford, R. R.
Hoffman, R. Jeffers, and T. Reichherzer. Terraforming Cyberspace.
In Computer, volume 34(7). IEEE, July 2001.
[5] A. J. Chakravarti, X. Wang, J. O. Hallstrom, and G. Baumgartner.
Implementation of Strong Mobility for Multi-
Threaded Agents in Java. Technical Report OSU-CISRC-
2/03-TR06, Department of Computer and Information Science,
The Ohio State University, February 2003.
[6] G. Cugola, C. Ghezzi, G. P. Picco, and G. Vigna. Analyzing
mobile code languages. In Mobile Object Systems: Towards
the Programmable Internet, number 1222 in Lecture Notes
in Computer Science. Springer-Verlag, 1996.
[7] G. Czajkowski and L. Dayn`es. Multitasking without Compromise:
A Virtual Machine Evolution. In Proceedings
of the 2001 ACM SIGPLAN Conference on Object-
Oriented Programming Systems, Languages and Applications,
Tampa, FL, Oct. 2001.
[8] I. Foster and A. Iamnitchi. On Death, Taxes, and the Convergence
of Peer-to-Peer and Grid Computing. In 2nd International
Workshop on Peer-to-Peer Systems, Berkeley, CA,
February 2003.
[9] I. Foster, C. Kesselman, and S. Tuecke. The Anatomy of
the Grid: Enabling Scalable Virtual Organizations. International
Journal of High Performance Computing Applications,
15(3), 2001.
[10] S. F¨unfrocken. Transparent Migration of Java-based Mobile
Agents: Capturing and Reestablishing the State of
Java Programs. In Proceedings of the Second International
Workshop on Mobile Agents, Stuttgart, Germany, September
1998.
[11] Gnutella. http://www.gnutella.com.
[12] R. S. Gray, G. Cybenko, D. Kotz, R. A. Peterson, and
D. Rus. D’Agents: Applications and Performance of a
Mobile-Agent System. Software— Practice and Experience,
32(6), May 2002.
[13] Grid Physics Network. http://www.griphyn.org.
[14] A. Holub. Reader/writer locks. Java World, April
1999. http://www.javaworld.com/javaworld/jw-04-1999/jw-
04-toolbox-p3.html.
[15] A. Iamnitchi, I. Foster, and D. Nurmi. A Peer-to-peer Approach
to Resource Discovery in Grid Environments. In 11th
Symposium on High Performance Distributed Computing,
Edinburgh, UK, August 2002.
[16] T. Illmann, T. Kr¨uger, F. Kargl, and M. Weber. Transparent
Migration of Mobile Agents using the Java Platform
Debugger Architecture. In Proceedings of the 5th International
Conference on Mobile Agents, Atlanta, GA, December
2001.
[17] H. Jiang and V. Chaudhary. Compile/Run-time Support for
Thread Migration. In 16th International Parallel and Distributed
Processing Symposium, Fort Lauderdale, FL, April
2002.
[18] H. Jiang and V. Chaudhary. On Improving Thread Migration:
Safety and Performance. In 9th International Conference
on High Performance Computing, Dec. 2002.
[19] D. Kotz, R. Gray, and D. Rus. Future Directions for Mobile-
Agent Research. IEEE Distributed Systems Online, 3(8),
August 2002. http://dsonline.computer.org/0208/f/kot.htm.
[20] D. B. Lange and M. Oshima. Programming & Deploying
Mobile Agents with Java Aglets. Addison-Wesley, 1998.
[21] D. Lea. Concurrent Programming in Java[tm]: Design
Principles and Patterns. The Java Series. Addison Wesley,
2nd edition, 1999.
[22] B. Overeinder, N. Wijngaards, M. van Steen, and F. Brazier.
Multi-Agent Support for Internet-Scale Grid Management.
In AISB’02 Symposium on AI and Grid Computing, April
2002.
[23] H. Peine and T. Stolpmann. The Architecture of the Ara
Platform for Mobile Agents. In First International Workshop
on Mobile Agents, Berlin, Germany, Apr. 1997.
[24] O. Rana and D. Walker. The Agent Grid: Agent-Based Resource
Integration in PSEs. In 16th IMACS World Congress
on Scientific Computation, Applied Mathematics and Simulation,
Lausanne, Switzerland, August 2000.
[25] T. Sakamoto, T. Sekiguchi, and A. Yonezawa. Bytecode
Transformation for Portable Thread Migration in Java. In
Proceedings of Agent Systems, Mobile Agents, and Applications,
2000.
[26] T. Sekiguchi, H. Masuhara, and A. Yonezawa. A Simple Extension
of Java Language for Controllable Transparent Migration
and its Portable Implementation. In Coordination
Models and Languages, 1999.
[27] SETI@home. http://setiathome.ssl.berkeley.edu.
[28] T. Suezawa. Persistent execution state of a Java virtual machine.
In Proceedings of the ACM 2000 conference on Java
Grande, 2000.
[29] N. Suri, J. M. Bradshaw, M. R. Breedy, P. T. Groth, G. A.
Hill, and R. Jeffers. Strong Mobility and Fine-Grained Resource
Control in NOMADS. In Proceedings of the Second
International Symposium on Agent Systems and Applications
/ Fourth International Symposium on Mobile Agents,
Zurich, Sept. 2000.
[30] E. Truyen, B. Robben, B. Vanhaute, T. Coninx, W. Joosen,
and P. Verbaeten. Portable Support for Transparent Thread
Migration in Java. In Proceedings of the Joint Symposium
on Agent Systems and Applications / Mobile Agents, Zurich,
Switzerland, September 2000.
[31] X. Wang. Translation from Strong Mobility to Weak Mobility
for Java. Master’s thesis, The Ohio State University,
2001.
[32] W. Zhu, C.-L. Wang, and F. C. M. Lau. JESSICA2: A Distributed
Java Virtual Machine with Transparent Thread Migration
Support. In IEEE Fourth International Conference
on Cluster Computing, Chicago, September 2002.
10 


  Conference Partner
Home
Conferences
Journals
Researchers
Login




 中文  |  English  |  日本語         
    
 


Conference Partner » Journals » International Journal of Grid Computing & Applications
  


 Journal Information



International Journal of Grid Computing & Applications (IJGCA)
http://airccse.org/journal/ijgca/ijgca.html 


Publisher: 

AIRCC 


ISSN: 

2229-3949 


Viewed: 

1122 


Tracked: 

0 


    


 Advertisment


    



 Call For Papers

Service-oriented computing is a popular design methodology for large scale business computing systems. Grid computing enables the sharing of distributed computing and data resources such as processing, networking and storage capacity to create a cohesive resource environment for executing distributed applications in service-oriented computing. Grid computing represents more business-oriented orchestration of pretty homogeneous and powerful distributed computing resources to optimize the execution of time consuming process as well. Grid computing have received a significant and sustained research interest in terms of designing and deploying large scale and high performance computational in e-Science and businesses. The objective of the journal is to serve as both the premier venue for presenting foremost research results in the area and as a forum for introducing and exploring new concepts.

Authors are solicited to contribute to this Open Access peer-reviewed Journal by submitting articles that illustrate research results, projects, surveying works and industrial experiences that describe significant advances in the following areas, but are not limited to

Topics of interest include but are not limited to, the following

    Applications, including eScience and eBusiness Applications
    Architectures and Fabrics
    Distributed and Large-Scale Data Access and Management
    Core Grid Infrastructure
    Peer to Peer Protocols in Grid Computing
    Network Support for Grid Computing
    Monitoring, Management and Organization Tools
    Networking and Security
    Performance Measurement and Modelling
    Metadata, Ontology, and Provenance
    Middleware and toolkits for Grid Computing
    Computing and Programming Models
    Programming Tools and Environments
    Distributed Problem Solving
    Creation and Management of Virtual Enterprises and Organizations
    Information Services
    Resource Management, Scheduling, and Runtime Environments
    Scientific, Industrial and Social Implications
    QoS and SLA Negotiation
    Grid Economy and Business Models
    Autonomic and Utility Computing on Global Grids
    Cluster and Grid Integration Issues
    Web Services, Semantic Grid and Web 2.0
    Grid related Applications

Last updated by Dou Sun in 2013-10-05



 Related Publications




 

 

 

 

 

 

 

 

 

 


 

 

 

 

 

 

 

 

 

 


More Publications >>



 Advertisment


    



 Related Journals




CCF

Full Name

Impact Factor

Publisher

ISSN


c Neural Computing & Applications 0.699 Springer 0941-0643 
 Neural Computing and Applications 1.168 Springer 0941-0643 
 Service Oriented Computing and Applications   Springer 1863-2386 
c Journal of Network and Computer Applications 0.660 ELSEVIER 1084-8045 
 International Journal of Advanced Computer Science and Applications 1.324 Science and Information 2158-107X 
b IEEE Computer Graphics and Applications   IEEE 0272-1716 
 International Journal on Computational Science & Applications   AIRCC 2200-0011 
c Journal of Grid Computing 1.556 Springer 1570-7873 
c International Journal of Computational Geometry and Applications   World Scientific 0218-1959 
 Journal of Computational Analysis and Applications   Springer 1521-1398 





 Related Conferences




CCF

CORE

QUALIS

Short

Full Name

Submission

Notification

Conference


 c  ICPCA International Conference on Pervasive Computing and Application 2014-08-15 2014-09-15 2014-12-03 
   ESSoS International Symposium on Engineering Secure Software and Systems 2014-09-08 2014-11-17 2015-03-04 
 b  TrustBus International Conference on Trust, Privacy, and Security in Digital Business 2015-04-30 2015-06-07 2015-09-01 
   CIA International Conference on Computer, Information and Application 2015-04-10 2015-04-30 2015-05-21 
b b a2 VMCAI International Conference on Verification, Model Checking, and Abstract Interpretation 2012-08-17 2012-10-12 2013-01-20 
   ICCDA International Conference on Computer Design and Applications 2011-03-01 2011-03-15 2011-05-27 
   ESA' International Conference on Embedded Systems and Applications 2015-04-15 2015-04-30 2015-07-27 
  b4 GreenCom International Conference on Green Computing and Communications 2015-07-15 2015-09-25 2015-12-11 
   GCIRE International Conference on Green Computing, Intelligent and Renewable Energies 2015-08-08 2015-08-18 2015-09-29 
   CSA International Conference on Computer Science and its Applications 2014-08-05 2014-08-20 2014-12-17 





 Comments



    

   Track It 0
   Edit CFP
   Add Issue

 


 Advertisment


    
   


1733 Conferences | 571 Journals | 1925 Researchers | 7,502,275 PV 
 Copyright © 2011-2015 myhuiban.com. All Rights Reserved. About Us | Post CFP or Contact Us | Promotion 
   


  Conference Partner
Home
Conferences
Journals
Researchers
Login




 中文  |  English  |  日本語         
    
 


Conference Partner » Journals » International Journal of Grid Computing & Applications
  


 Journal Information



International Journal of Grid Computing & Applications (IJGCA)
http://airccse.org/journal/ijgca/ijgca.html 


Publisher: 

AIRCC 


ISSN: 

2229-3949 


Viewed: 

1122 


Tracked: 

0 


    


 Advertisment


    



 Call For Papers

Service-oriented computing is a popular design methodology for large scale business computing systems. Grid computing enables the sharing of distributed computing and data resources such as processing, networking and storage capacity to create a cohesive resource environment for executing distributed applications in service-oriented computing. Grid computing represents more business-oriented orchestration of pretty homogeneous and powerful distributed computing resources to optimize the execution of time consuming process as well. Grid computing have received a significant and sustained research interest in terms of designing and deploying large scale and high performance computational in e-Science and businesses. The objective of the journal is to serve as both the premier venue for presenting foremost research results in the area and as a forum for introducing and exploring new concepts.

Authors are solicited to contribute to this Open Access peer-reviewed Journal by submitting articles that illustrate research results, projects, surveying works and industrial experiences that describe significant advances in the following areas, but are not limited to

Topics of interest include but are not limited to, the following

    Applications, including eScience and eBusiness Applications
    Architectures and Fabrics
    Distributed and Large-Scale Data Access and Management
    Core Grid Infrastructure
    Peer to Peer Protocols in Grid Computing
    Network Support for Grid Computing
    Monitoring, Management and Organization Tools
    Networking and Security
    Performance Measurement and Modelling
    Metadata, Ontology, and Provenance
    Middleware and toolkits for Grid Computing
    Computing and Programming Models
    Programming Tools and Environments
    Distributed Problem Solving
    Creation and Management of Virtual Enterprises and Organizations
    Information Services
    Resource Management, Scheduling, and Runtime Environments
    Scientific, Industrial and Social Implications
    QoS and SLA Negotiation
    Grid Economy and Business Models
    Autonomic and Utility Computing on Global Grids
    Cluster and Grid Integration Issues
    Web Services, Semantic Grid and Web 2.0
    Grid related Applications

Last updated by Dou Sun in 2013-10-05



 Related Publications




 

 

 

 

 

 

 

 

 

 


 

 

 

 

 

 

 

 

 

 


More Publications >>



 Advertisment


    



 Related Journals




CCF

Full Name

Impact Factor

Publisher

ISSN


c Neural Computing & Applications 0.699 Springer 0941-0643 
 Neural Computing and Applications 1.168 Springer 0941-0643 
 Service Oriented Computing and Applications   Springer 1863-2386 
c Journal of Network and Computer Applications 0.660 ELSEVIER 1084-8045 
 International Journal of Advanced Computer Science and Applications 1.324 Science and Information 2158-107X 
b IEEE Computer Graphics and Applications   IEEE 0272-1716 
 International Journal on Computational Science & Applications   AIRCC 2200-0011 
c Journal of Grid Computing 1.556 Springer 1570-7873 
c International Journal of Computational Geometry and Applications   World Scientific 0218-1959 
 Journal of Computational Analysis and Applications   Springer 1521-1398 





 Related Conferences




CCF

CORE

QUALIS

Short

Full Name

Submission

Notification

Conference


 c  ICPCA International Conference on Pervasive Computing and Application 2014-08-15 2014-09-15 2014-12-03 
   ESSoS International Symposium on Engineering Secure Software and Systems 2014-09-08 2014-11-17 2015-03-04 
 b  TrustBus International Conference on Trust, Privacy, and Security in Digital Business 2015-04-30 2015-06-07 2015-09-01 
   CIA International Conference on Computer, Information and Application 2015-04-10 2015-04-30 2015-05-21 
b b a2 VMCAI International Conference on Verification, Model Checking, and Abstract Interpretation 2012-08-17 2012-10-12 2013-01-20 
   ICCDA International Conference on Computer Design and Applications 2011-03-01 2011-03-15 2011-05-27 
   ESA' International Conference on Embedded Systems and Applications 2015-04-15 2015-04-30 2015-07-27 
  b4 GreenCom International Conference on Green Computing and Communications 2015-07-15 2015-09-25 2015-12-11 
   GCIRE International Conference on Green Computing, Intelligent and Renewable Energies 2015-08-08 2015-08-18 2015-09-29 
   CSA International Conference on Computer Science and its Applications 2014-08-05 2014-08-20 2014-12-17 





 Comments



    

   Track It 0
   Edit CFP
   Add Issue

 


 Advertisment


    
   


(c)[adrian.orozco.jimenez.acosta.gamez](c)
  
